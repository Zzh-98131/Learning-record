# 前端学习记录

> 曾泽华 2020.07.31 始

## 项目搭建

### 环境安装

#### 安装Node

安装*node.js*，全部默认。在<u>环境变量-用户变量-Path</u>中，添加*node.js*路径。安装完毕后在控制台输入：
`node-v`
即可查看node版本。

#### 安装淘宝镜像

打开cmd执行如下命令： 
`npm install -g cnpm --registry=https://registry.npm.taobao.org`
用于加速依赖的下载。 后续使用到npm下载依赖的命令，都可以替换成cnpm来加速下载。

#### 安装Vue及脚手架

Window 下用 CMD 命令行执行：
1.`cnpm i -g vue`
2.`cnpm install -g @vue/cli`

#### 安装i18n国际化配置

**npm安装**

```shell
npm i vue-i18n
```

**引入及配置**

在`src`文件夹下新建`lang`文件夹，`lang`文件夹下新建三个文件：`en.js`（英文语言包）,`index.js`,`zh.js`（中文语言包）。



#### 安装Element UI

https://element.eleme.cn/#/zh-CN/component/installation

**npm安装**

官网：https://element.eleme.cn/#/zh-CN/component/installation

官网推荐使用npm方式安装，它能更好地和*webpack*打包工具配合使用。

```shell
npm i element-ui -S
```

**CDN安装**

目前可以通过 [unpkg.com/element-ui](https://unpkg.com/element-ui/) 获取到最新版本的资源，在页面上引入 *js* 和 *css* 文件即可开始使用。

```html
<!-- 引入样式 -->
<link rel="stylesheet" href="https://unpkg.com/element-ui/lib/theme-chalk/index.css">
<!-- 引入组件库 -->
<script src="https://unpkg.com/element-ui/lib/index.js"></script>
```

#### 安装js-cookie

[在Vue中怎么使用 cookie 之 js-cookie](https://www.jianshu.com/p/6307073f5fa4)

**安装**

```undefined
npm install js-cookie --save
```

**引用**

首先在 main.js 导入

```jsx
import jsCookie from 'js-cookie'
```

然后把他放在Vue原型l里, 在页面里可直接用 `this.$cookie`调用

```javascript
Vue.prototype.$cookie = jsCookie;
```

**设置 cookie**

```kotlin
this.$cookie.set('key', 'value');
```

还可以设置cookie的有效期 / 路径 /所在域 等, 如下

```kotlin
this.$cookie.set('name', 'value', { expires: 7, path: '/a' });
```

即为`/a`路径设置了一个有效期为 7 天的cookie
 如上, 第三个参数是个`对象`, 可设置你想设置的cookie的属性, 如下

> `1.expires` : 定义有效期。如传入Number，则单位为天，也可传入一个Date对象，表示有效期至Date指定时间。
> 默认情况下cookie有效期截止至用户退出浏览器。
> `2.path` : string，表示此cookie对哪个地址可见。默认为”/”。
> `3.domain` : string，表示此cookie对哪个域名可见。设置后cookie会对所有子域名可见。
> 默认为对创建此cookie的域名和子域名可见。
> `4.secure` : true或false，表示cookie传输是否仅支持https。默认为不要求协议必须为https。

**获得 cookie**

获得某个cookie

```javascript
// this.$cookie.get('cookie-name');
this.$cookie.get('name'); // return  'value'
```

获得所有的cookie

```javascript
// 不传值 即 获得所有 cookie 的值
this.$cookie.get(); // retuen { name1: 'value1', name2: 'value2', ...}
```

获得指定的cookie

```javascript
// 获得 xxx.xxxx.com 域下的 cookie
this.$cookie.get('name', { domain: 'xxx.xxxx.com' })
```

**删除 cookie**

```javascript
// 只需要指定 cookie 的 name即可
this.$cookie.remove('name');
```

> 如果值设置了路径，则不能用简单的delete方法删除值，需在delete时指定路径

```javascript
this.$cookie.set('name', 'value', { path: '' });
this.$cookie.remove('name'); // 删除失败
this.$cookie.remove('name', { path: '' }); // 删除成功
```

> 注意 : 删除不存在的cookie不会报错也不会有返回

**JSON 用法**

cookie 一般只保存 string, 当你传入Array或对象，而不是简单的string，那么js-cookie会将你传入的数据用 JSON.stringify 悄悄的转换为string保存。

```javascript
this.$cookie.set('name', { key1: 'value1' });
this.$cookie.get('name'); // return  '{"key1":"value1"}'
this.$cookie.get(); // return  { name: '{"key1":"key1"}' }
```

也可用getJSON获取cookie，则js-cookie会用JSON.parse解析string并返回。

```javascript
this.$cookie.getJSON('name'); // return { key1: 'key1' }
this.$cookie.getJSON(); // return { name: { key1: 'key1' } }
```

**自定义覆盖**

通过withConverter方法可以覆写默认的decode实现，并返回一个新的cookie实例。所有与decode有关的get操作，如Cookies.get()或Cookies.get(‘name’)都会先执行此方法中的代码。

```javascript
document.cookie = 'escaped=%u5317';
document.cookie = 'default=%E5%8C%97';
let cookiesNew = this.$cookie.withConverter((value, name) => {
    if ( name === 'escaped' ) {
        return unescape(value);
    }
});
cookiesNew .get('escaped'); // 北
cookiesNew .get('default'); // 北
cookiesNew .get(); // { escaped: '北', default: '北' }
```

通过withConverter方法也可以覆写默认的encode实现，并返回一个新的cookie实例。

```javascript
this.$cookie.withConverter({
    read: function (value, name) {
        // Read converter
    },
    write: function (value, name) {
        // Write converter
    }
});
```

#### 安装qs

```shell
npm install qs
```

**全局引用**

```js
//在main.js引入qs
import  qs from 'qs'

//配全局属性配置，在任意组件内可以使用this.$qs获取qs对象

 Vue.prototype.$qs = qs
```

**局部接口文件引用**

```js
var qs = require('qs')
```

**qs.parse()**

`qs.parse()`是**将URL解析成对象**的形式
我遇到的问题就是使用此方法解决的。因为后端@RequestBody注解对应的类在将HTTP的输入流(含请求体)装配到目标类(即：@RequestBody后面的类)时，会根据json字符串中的key来匹配对应实体类的属性，如果匹配一致且json中的该key对应的值符合(或可转换为)。

**qs.stringify()**

`qs.stringify()`将**对象序列化成URL的形式**以`&`进行拼接

```js
const Qs = require('qs');
let obj= {
 method: "query_sql_dataset_data",
 projectId: "85",
 appToken: "7d22e38e-5717-11e7-907b-a6006ad3dba0",
 datasetId: " 12564701"
  };
Qs.stringify(obj);
console.log(Qs.stringify(obj));
```

**区别**

```js
/* JSON.stringify(param) */
{"uid":"cs11","pwd":"000000als","username":"cs11","password":"000000als"}
```

```js
/* Qs.stringify(param) */
uid=cs11&pwd=000000als&username=cs11&password=000000als
```

**如上所示，前者是采用JSON.stringify(param)进行处理，后者是采用Qs.stringify(param)进行处理的。**

#### 安装Vue Baidu Map

安装文档：https://dafrok.github.io/vue-baidu-map/#/zh/start/installation

参考文档：http://lbsyun.baidu.com/cms/jsapi/reference/jsapi_reference.html#a2b2

**NPM**

```shell
$ npm install vue-baidu-map --save
```

**全局注册**

全局注册将一次性引入百度地图组件库的所有组件。

```javascript
import Vue from 'vue'
import BaiduMap from 'vue-baidu-map'

Vue.use(BaiduMap, {
  // ak 是在百度地图开发者平台申请的密钥 详见 http://lbsyun.baidu.com/apiconsole/key */
  ak: 'YOUR_APP_KEY'
})
```

```js
<template>
  <baidu-map class="bm-view">
  </baidu-map>
</template>

<style>
.bm-view {
  width: 100%;
  height: 300px;
}
</style>
```

**局部注册**

如果有按需引入组件的需要，可以选择局部注册百度地图组件，这将减少工程打包后的容量尺寸。局部注册的 `BaiduMap` 组件**必须**声明 `ak` 属性。 所有的独立组件均存放在 `vue-baidu-map/components` 文件夹下，按需引用即可。 由于未编译的 ES 模块不能在大多数浏览器中直接运行，如果引入组件时发生运行时错误，请检查 webpack 的 loader 配置，确认 `include` 和 `exclude` 选项命中了组件库

```js
<template>
  <baidu-map class="bm-view" ak="YOUR_APP_KEY">
  </baidu-map>
</template>

<script>
import BaiduMap from 'vue-baidu-map/components/map/Map.vue'
export default {
  components: {
    BaiduMap
  }
}
</script>

<style>
.bm-view {
  width: 100%;
  height: 300px;
}
</style>
```

**常见问题**

- `BaiduMap` 组件容器本身是一个空的块级元素，如果容器不定义高度，百度地图将渲染在一个高度为 0 不可见的容器内。
- 没有设置 `center` 和 `zoom` 属性的地图组件是不进行地图渲染的。当`center` 属性为合法地名字符串时例外，因为百度地图会根据地名自动调整 `zoom` 的值。
- 由于百度地图 JS API 只有 JSONP 一种加载方式，因此 `BaiduMap` 组件及其所有子组件的渲染只能是异步的。因此，请使用在组件的 `ready` 事件来执行地图 API 加载完毕后才能执行的代码，不要试图在 vue 自身的生命周期中调用 `BMap` 类，更不要在这些时机修改 model 层。

**错误用法**

```js
<template>
  <baidu-map :center="center" :zoom="zoom"></baidu-map>
</template>
<script>
export default {
  data () {
    return {
      center: {lng: 0, lat: 0},
      zoom: 3
    }
  },
  mounted () {
    this.lng = 116.404
    this.lat = 39.915
    this.zoom = 15
  }
}
</script>
```

**正确用法**

```html
<template>
  <baidu-map :center="center" :zoom="zoom" @ready="handler"></baidu-map>
</template>
<script>
export default {
  data () {
    return {
      center: {lng: 0, lat: 0},
      zoom: 3,
      map: null
    }
  },
  methods: {
    handler ({BMap, map}) {
      console.log(BMap, map)
      this.center.lng = 116.404
      this.center.lat = 39.915
      this.zoom = 15
      this.map = map // 此处将地图实例保存下来，方便在外部调用
    }
  }
}
</script>
```

去掉百度地图标志和底部文字（可在全局样式中设置）：

```css
.BMap_cpyCtrl {
  display: none;
}
.anchorBL {
  display: none;
}
```

[百度地图开发文档](http://lbsyun.baidu.com/cms/jsapi/reference/jsapi_reference.html)

例如：要使用启用滚轮缩放功能

```js
handler ({BMap, map}) {
   console.log(BMap, map)
   map.enableScrollWheelZoom(true)
   this.center.lng = 116.404
   this.center.lat = 39.915
   this.zoom = 15
}
```

例如：要使用拖拽标记点返回坐标功能

```html
<bm-marker
  :dragging="true"
  :title="this.$t('按住拖拽')"
  @dragend="markDrag"
/>
```

```js
markDrag(marker) {
  console.log(marker)
}
```

这样就能获取到标记点实例了

#### 安装axios

```shell
npm install axios --save
```

#### 安装HBuilderX

选择纯净版本（不含插件），自行安装以下插件：

- eslint-js
- eslint-plugin-vue
- git插件
- htmlhint
- scss/sass编译
- stylelint
- SVN插件
- easy-git

浏览器选择Googe浏览器

解压*vue-devtools.zip*，打开谷歌浏览器点击右上角拼图图标，进入扩展程序管理，将解压后的文件夹拖入浏览器安装检查插件。

在Vue官网：https://cn.vuejs.org/v2/guide/installation.html下载开发版本*vue.js*，在项目文件中直接用`<script>`标签引入，vue会被注册为一个全局变量。

将项目文件夹直接拉入HBuilderX，右键项目用(CMD)命令打开，执行：`cnpm i`下载依赖。

自行配置本地项目路径后，运行项目：`npm run dev`

#### 国际化规则

若使用了国际化插件，例如：

`:label="$t('table.createTime')"`

- 元素内的标签加 : 绑定符 ，值为： `"$t('类型.key')"`
- Js中使用： `this.$t('table.createTime');`
- 元素中使用： `{{ $t('table.createTime' ) }}`

### 细节配置

#### 一个好用的聚焦提示的教学模块

[github地址](https://github.com/kamranahmedse/driver.js)

[示例](https://kamranahmed.info/driver.js/#single-element-no-popover)

#### vue项目使用vuex定时器统一管理

如果直接在每个组件中定义定时器`setInterval`，会造成定时器重复创建，无法销毁的情况。
因此通过状态管理vuex来统一管理定时器状态，使得多个组件仅创建一个定时器变量`this.$store.state.timer`，同时各组件的定时器又独立存在

**设计逻辑**

在`vuex`的`getters`中获取`timer`（接口），使得在外部可以访问到内部状态。

```js
timer: state => state.app.timer
```

如有模块化，在对应的模块中编写，如app.js

```js
// 状态初始化
const state = {
    timer: null
}

// 可进行异步操作的actions
const actions = {
    /**
   * 定时器设置
   * 使用方式：this.$store.dispatch('app/setTimer', {
     interval: 3 * 1000, // 轮询间隔，单位毫秒
     functions: () => { // 注意应使用箭头函数，此处放置需要轮询的操作
       this.getData()
     }
   })
   */
  setTimer({ commit }, { interval, functions }) {
    commit('SET_TIMER', { interval, functions })
  },
  /**
   * 清除定时器
   * 使用方式：this.$store.dispatch('app/clearTimer')
   */
  clearTimer({ commit }) {
    commit('CLEAR_TIMER')
  }
}

// 触发状态变化的mutations，其接收的第一个参数为state
const mutations = {
    SET_TIMER: (state, { interval, functions }) => {
    state.timer = setInterval(() => {
      functions()
    }, interval)
  },
  CLEAR_TIMER: (state) => {
    clearInterval(state.timer)
    state.timer = null
  }
}
```

具体组件中使用定时器时：

```js
// 首先引入vuex的mapGetters
import { mapGetters } from 'vuex'

// 然后在计算属性中注册
computed: {
    ...mapGetters([
        'timer'
    ])
}

// 在组件销毁之前清除定时器
beforeDestory() {
    this.clearTimer
}
clearTimer() {
    if (this.timer) {
       this.$store.dispatch('app/clearTimer')
    }
}

// 使用定时器
 setTimer() {
   const IntervalTime = 5 * 1000
   /**
    * dispatch函数分发到vuex的app.js的actions的setTimer操作中，actions可包含异步函数
    * 后面传参一个对象 {
    *   interval: Number类型，定义定时器刷新时间
    *   functions: 方法，需写成箭头函数形式，里面放需要刷新的方法
    * }
    * 不可再继续添加传参，若要添加新的传参，放入上面的对象中
    */
   this.$store.dispatch('app/setTimer', {
     interval: IntervalTime,
     functions: () => {
       if (this.device.length > 0) {
         this.fresh() // 需要刷新的接口，或是需要重复的操作
       }
     }
   })
 }
```

#### el-table行悬浮样式重写

```scss
.el-table {
    th { // 表头
  		background-color: rgb(242, 242, 242);
	}
	tr:hover>td {
  		background-color: rgb(242, 242, 242) 		!important;
	}
}
```

#### 页面动态标题

路由中设置`meta`

```js
{
  path: 'home',
  name: 'home',
  component: () => import('@/components/views/index/index.vue'),
  meta: {
    title: '首页' + appendTitle
  }
}
```

`main.js`中设置路由拦截

```js
// 动态标题
router.beforeEach((to, from, next) => {
  if (to.meta.title) {
    document.title = to.meta.title
  } else {
    document.title = '综合管理系统'
  }
  next()
})
```

#### 百度地图InfoWindow样式设置

设置全局样式`scss`文件`baidu-map.scss`

```scss
.BMap_pop {
  color: #FFFFFF;

  > div:nth-child(1) { // 左上小方块
    background-color: #000000 !important;
    display: none;
  }

  > div:nth-child(2) { // BMap_top
    background-color: #ffaa00;
    display: none;
  }

  > div:nth-child(3) { // 右上小方块
    background-color: #000000 !important;
    display: none;
  }
  > img {
    display: none;
  }

  > div:nth-child(4) { // BMap_center
    background-color: #aa0000;
    display: none;
  }

  > div:nth-child(5) { // 左下小方块
    background-color: #000000 !important;
    display: none;
  }

  > div:nth-child(6) { // BMap_bottom
    background-color: #ffaaff;
    display: none;
  }

  > div:nth-child(7) { // 右下小方块
    background-color: #000000 !important;
    display: none;
  }

  > div:nth-child(8) { // 底部小箭头
    color: #000000;
    display: none;
    background-color: #5555ff;
  }

  > div:nth-child(9) { // 自定义内容区
    background-color: rgba(14, 23, 57, 0.8);
    padding: 0 10px;
    border-radius: 10px;
  }

}
```

`InfoWindow`由9个区域组成，分别是：

1. 左上角小方块
2. 顶部内容，相当于`BMap_top`
3. 右上角小方块
4. 中央区域，相当于`BMap_center`
5. 左下角小方块
6. 底部内容， 相当于`BMap_bottom`
7. 右下角小方块
8. 底部箭头
9. 自定义内容区

![image-20210127104353498](D:\易事特工作\Vue学习\MarkDown\前端学习\百度地图InfoWindow.png)

#### vue全屏组件screenfull

```shell
npm install --save screenfull
```

新建全屏组件文件`screenfull_item.vue`，并引入

```js
import screenfull from 'screenfull'
```

准备好全屏和取消全屏的两个`svg`图片：

```html
<svg-icon
  :icon-class="isFullscreen ? 'window_mode' : 'screenfull'"
  style="font-size: 30px;"
  @click="click"
/>
```

完整代码：

```vue
<template>
  <div>
    <svg-icon
      :icon-class="isFullscreen ? 'window_mode' : 'screenfull'"
      style="font-size: 30px;"
      @click="click"
    />
  </div>
</template>

<script>
import screenfull from 'screenfull'
export default {
  name: 'screenfull_item',
  data() {
    return {
      isFullscreen: false
    }
  },
  mounted() {
    this.init()
  },
  beforeDestroy() {
    this.destroy()
  },
  methods: {
    click() {
      if (!screenfull.isEnabled) {
        this.$message({
          message: this.$t('暂不支持全屏'),
          type: 'warning',
          offset: 70
        })
        return false
      }
      screenfull.toggle()
    },
    change() {
      this.isFullscreen = screenfull.isFullscreen
    },
    init() {
      if (screenfull.isEnabled) {
        screenfull.on('change', this.change)
      }
    },
    destroy() {
      if (screenfull.isEnabled) {
        screenfull.off('change', this.change)
      }
    }
  }
}
</script>

<style scoped>
</style>

```

#### 侧栏的高亮、悬浮联动样式逻辑

这个功能困扰了我几乎一整个月，最后终于实现了，走了不少弯路，因此记录一下。

**功能需求：**

| 侧栏展开时                                                   | 侧栏收缩时                                                   |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| 鼠标悬浮效果：悬浮到任意一项时触发高亮样式（`hover`），且悬浮到子菜单时，其所有父级项同样触发高亮样式（`hover`），移出时包括自身，所有对应父级项的高亮样式消失。 | 鼠标悬浮效果：侧栏收缩时只有图标没有文字，鼠标悬浮到图标上后，触发高亮样式（`hover`），弹出该项所属的下级子菜单；鼠标移动到子菜单上后，保持父级的高亮样式不变，若该子菜单项也有子集，则继续弹出其所属子菜单，同样保证其所有父级高亮。鼠标移出菜单范围，所有高亮消失。 |
| 当前路由高亮效果：侧栏中，当前页面的路由包括自身及其所有父级项保持高亮（`hover`）状态，不受鼠标悬浮影响，即鼠标移入移出当前页面所在的菜单及其父级项，高亮（`hover`）效果不会消失。 | 当前路由高亮效果：当前页面所在的项的所有父级保持高亮。       |

**实现思路：**

侧栏`html`部分采用递归的方式实现：

```vue
<!-- 侧栏menu组件 -->
<template>
  <div class="app-aside">
    <el-scrollbar>
      <div class="menu_logo" :class="{menu_logo_opened:sidebar.opened,menu_logo_hidden:!sidebar.opened}" @click="toHome">
        <img src="../../../assets/img/logo.png" width="32px" height="40px" />
        <span class="menu_title" v-if="sidebar.opened">{{ $t('综合管理系统') }}</span>
      </div>
      <el-menu
        :default-active="activeMenu"
        :collapse="isCollapse"
        :collapse-transition="false"
        :unique-opened="true"
        :router="true"
        :background-color="variables.side_nav_bar_background_color"
        :active-text-color="variables.side_active_color"
        mode="vertical"
        @open="openMenu"
        @select="openMenu"
      >
      <!-- :text-color="variables.side_word_color"
      :background-color="variables.side_nav_bar_background_color"
      :active-text-color="variables.side_active_color" -->
        <menu-item v-for="(items, index) in menu" :key="index" :opened="sidebar.opened" :menu="items" :route-arr="routeArr" />
      </el-menu>
    </el-scrollbar>
  </div>
</template>
```

然后递归子集：

```vue
<!-- 侧栏menu-item组件 -->
<template>
  <div class="menu_item_wrap" @mouseenter="mouseEnter(menu)" @mouseleave="mouseLeave(menu)">
    <el-submenu :class="{parents:menu.parentId===0}" :index="menu.menuURL||menu.menuText" v-if="menu.perms==='perms'&&menu.items&&menu.items[0].order!==0"><!-- 有子菜单 -->
      <template slot="title">
        <div class="tit_sub" :class="{hover_me:menu.isLight||isHover}">
          <svg-icon v-if="menu.menuIcon!=='icon'&&menu.menuIcon&&menu.menuIcon!=='glyphicon'" :icon-class="menu.menuIcon" />
          <span v-if="sidebar.opened||menu.id!==5395&&menu.id!==5396&&menu.id!==5397">{{ menu.menuText }}</span>
        </div>
      </template>
      <menu-item v-for="child in menu.items" :key="child.menuText" :opened="opened" :menu="child" :route-arr="routeArr" @isHovering="childIsHolded" @afterHover="parentFree" />
    </el-submenu>

    <el-menu-item v-else :index="menu.menuURL" ref="menuItem">
      <svg-icon v-if="menu.menuIcon!=='icon'&&menu.menuIcon&&menu.menuIcon!=='glyphicon'" :icon-class="menu.menuIcon" />
      <span>{{ menu.menuText }}</span>
    </el-menu-item>
  </div>
</template>
```

**当前路由高亮功能实现思路：**

因为侧栏使用了el-menu组件中的路由跳转功能`:router="true"`，`el-menu-item`的`index`变为了菜单数据结构中含有的路由路径`:index="menu.menuURL"`，比如当前地址：http://localhost:8080/#/home，则在菜单数据结构的某项中就有：

```js
{
	id:5128,
	menuText: '首页',
	menuURL: '/home',
	...
}
```

因此，通过获取路由的路径：`this.$route.path`，就能定位到当前页面在菜单数据结构中对应的是具体哪一项。

举个例子，当前页为首页，路由路径：`/home`。在菜单数据结构的位置为：

```js
{
	id: 5397,
	menuText: '监控管理',
	menuURL: '',
    parentId: 0,
    isLight: false,
	items: [
		{
			id: 5128,
			menuText: '首页',
          	parentId: 5397,
            isLight: false,
            menuURL: '/home'
		}，
        {
			id: 5129,
			menuText: '数据管理',
        	parentId: 5397,
        	isLight: false,
            menuURL: '/dataManager',
        	items: [
        		{
        			id: 5050,
        			menuText: '设备管理',
        			parentId: 5129,
        			isLight: false,
        			menuURL: '/deviceManager'
        		}
    		]
		}
	]
}
```

则可以通过深度遍历菜单树，对比`menuURL`来获取到`/home`所对应的路由路径数组：

```js
traverseToGetRouteArr(menu, route) { // 获取路由路径数组
  for (let i = 0; i < menu.length; i++) {
    var menuItem = menu[i]
    if (menuItem.items) {
      this.traverseToGetRouteArr(menuItem.items, route) // 深度遍历
      if (this.routeArr.length !== 0) { // 如果已经找到了路由，直接往父节点返回
        this.routeArr.unshift(menuItem.parentId)
        break
      } else {
        if (route === menuItem.menuURL) { // 在菜单中定位当前路由
          this.routeArr.unshift(menuItem.parentId)
          console.log(menuItem.parentId)
          break
        }
      }
    } else { // 当items为null
      if (route === menuItem.menuURL) { // 在菜单中定位当前路由
        this.routeArr.unshift(menuItem.parentId)
        console.log(menuItem.parentId)
        break
      }
    }
  }
}
```

可得首页的路由路径数组（不包括自己）为：[5397]；或者设备管理页的路由路径数组为：[5397, 5129]。然后，根据路由路径数组，在菜单数据结构中对数组里的项设置高亮标记`isLight: true`，渲染侧栏时，遇到高亮标记为`true`的项，就设为高亮样式。

**鼠标悬浮效果实现思路：**困扰我一个月的问题在于鼠标悬浮，一直有个bug解决不掉，就是鼠标悬浮到子集，所有对应父级高亮，但是鼠标离开菜单范围后，**根父级的高亮不消失**，最后是通过添加高亮取消判断才解决这个bug。

高亮触发判断思路：在上面提到的侧栏`menu-item`组件中，我是通过一个布尔变量来标记该菜单项是否被hover的，即

```js
data() {
  return {
    isHover: false,
  }
}
```

因为`menu-item`组件是递归的，所以每个菜单项都有独立的`isHover`标记，它们相互独立。那么怎么判断我当前的项该不该高亮呢？

在上面展示的部分菜单数据结构中，可以看到其中一个父子关系：**监控管理->数据管理->设备管理**，悬浮高亮的难点在于，鼠标悬浮在`设备管理`上，得顺藤摸瓜找出它的父亲、爷爷。

这里使用了鼠标移入移出的回调方法来判断鼠标悬浮的是哪一项：

```vue
<div class="menu_item_wrap" @mouseenter="mouseEnter(menu)" @mouseleave="mouseLeave(menu)">
```

```js
mouseEnter(menu) {
  this.isHover = true
  this.$emit('isHovering', menu.parentId)
},
mouseLeave(menu) {
  this.isHover = false
  this.$emit('afterHover', menu.parentId)
}
```

其中，方法触发isHover = true/false表示鼠标移入当前项高亮，移出当前项高亮消失。此外，关键代码是`this.$emit('isHovering', menu.parentId)`和`this.$emit('afterHover', menu.parentId)`移入时，不仅当前项高亮，还要将该项的父级`id`送到父级去判断，当父级判断传入的`id`与本身id相等时，高亮触发。

```js
parentFree(pId) { // 移出取消高亮
  if (pId===this.menu.id) {
    this.isHover = false
  }
},
childIsHolded(pId) { // 移入触发高亮
  if (pId===this.menu.id) {
    this.isHover = true
  }
}
```



#### Element UI的菜单弹出框内上下的空白

```scss
.el-menu--popup { // 无空白
	padding: 0px;
}
```

#### Element UI的菜单弹出框之间的空隙

```scss
.el-menu--popup-right-start { // 空隙为0
	margin-left: 0px;
	margin-right: 0px;
}
```

#### Element UI的菜单弹出框宽度调整

官网为其设置了最小宽度`min-width: 200px;`小于`200px`之后就无效了，因此样式重写的时候需要设置`min-width`覆盖。

#### [vue路由中子集的path项没有/符号](https://www.imooc.com/wenda/detail/519518)

若有`/`：

```js
{
	path: '/father',
	children: {
        path: '/child'
    }
}
```

当子集的`path: '/url'`加上了`/`，则访问该页面时，路由路径直接就是`/child`。

若无`/`：

```js
{
	path: '/father',
	children: {
        path: 'child'
    }
}
```

当子集的`path: 'url'`没有`/`，则访问该页面时，路由路径会将该子集`path`作为**字符串拼接到父级路由**`url`上：`/father/child`。

#### [vue连接开发服务器](https://blog.csdn.net/weixin_42118466/article/details/89810625)

向后台要IP（域名和端口号）`http://192.168.xxx.xx:8080/xxxx-xxxxxxxx`

在vue项目的*config*文件下的`index.js`中，设置开发环境dev，配置后台代理：

```js
proxyTable: { // 配置后台代理
      '/api_edims': {
        target:  // 本地测试环境请求后台接口的域名和端口号
        'http://192.168.xxx.xx:8080/xxxx-xxxxxxxx', // 这里是向后台要到的IP
        changeOrigin: true, // 开启代理

        pathRewrite: {
          '^/api_edims': '' //这里理解成用‘/api_edims’代替target里面的地址，后面组件中我们掉接口时直接用api代替 比如我要调用'http://40.00.100.100:3002/user/add'，直接写‘/api/user/add’即可
        }
      },
      '/socket': {
        target: 'ws://192.168.xxx.xx:8080/xxxx-xxxxxxxx',
        changeOrigin: true,
        ws: true,
        secure: false,
        pathRewrite: {
          '^/socket': ''
        }
      }
    }
```

完整`index.js`代码：

```js
'use strict'
// Template version: 1.3.1
// see http://vuejs-templates.github.io/webpack for documentation.

const path = require('path')

module.exports = {
  dev: { // dev环境

    // Paths
    assetsSubDirectory: 'static', // 编译输出的二级目录
    assetsPublicPath: '/', // 编译发布的根目录，可配置为资源服务器域名或CDN域名
    proxyTable: { // 配置后台代理
      '/api_edims': {
        target:  // 本地测试环境请求后台接口的域名和端口号
        'http://192.168.xxx.xx:8080/xxxx-xxxxxxxx',
        changeOrigin: true, // 开启代理

        pathRewrite: {
          '^/api_edims': '' //这里理解成用‘/api_edims’代替target里面的地址，后面组件中我们掉接口时直接用api代替 比如我要调用'http://40.00.100.100:3002/user/add'，直接写‘/api/user/add’即可
        }
      },
      '/socket': {
        target: 'ws://192.168.xxx.xx:8080/xxxx-xxxxxxxx',
        changeOrigin: true,
        ws: true,
        secure: false,
        pathRewrite: {
          '^/socket': ''
        }
      }
    },

    // Various Dev Server settings
    host: 'localhost', // can be overwritten by process.env.HOST
    port: 8080, // can be overwritten by process.env.PORT, if port is in use, a free one will be determined
    autoOpenBrowser: true, // 运行时自动打开浏览器
    errorOverlay: true,
    notifyOnErrors: true,
    poll: false, // https://webpack.js.org/configuration/dev-server/#devserver-watchoptions-


    /**
     * Source Maps
     */

    // https://webpack.js.org/configuration/devtool/#development
    devtool: 'cheap-module-eval-source-map',

    // If you have problems debugging vue-files in devtools,
    // set this to false - it *may* help
    // https://vue-loader.vuejs.org/en/options.html#cachebusting
    cacheBusting: true,

    cssSourceMap: true
  },

  build: { // production环境
    // Template for index.html
    index: path.resolve(__dirname, '../dist/index.html'),

    // Paths
    assetsRoot: path.resolve(__dirname, '../dist'),
    assetsSubDirectory: 'static',
    assetsPublicPath: '/',

    /**
     * Source Maps
     */

    productionSourceMap: true,
    // https://webpack.js.org/configuration/devtool/#production
    devtool: '#source-map',

    // Gzip off by default as many popular static hosts such as
    // Surge or Netlify already gzip all static assets for you.
    // Before setting to `true`, make sure to:
    // npm install --save-dev compression-webpack-plugin
    productionGzip: false,
    productionGzipExtensions: ['js', 'css'],

    // Run the build command with an extra argument to
    // View the bundle analyzer report after build finishes:
    // `npm run build --report`
    // Set to `true` or `false` to always turn it on or off
    bundleAnalyzerReport: process.env.npm_config_report
  }
}

```

配置开发环境参数，同样是*config*下的`dev.env.js`：

```js
'use strict'
const merge = require('webpack-merge')
const prodEnv = require('./prod.env')

module.exports = merge(prodEnv, {
  NODE_ENV: '"development"',
  API_HOST: '"/api_edims/"',
  WS_HOST: '"/socket/"'
})
```

最后是生产环境，*config*下的`prod.env.js`：

```js
'use strict'
module.exports = {
  NODE_ENV: '"production"',
  API_HOST: 'api_edims/',
  WS_HOST: '"/socket/"'
}
```

#### [vue接口的使用](http://www.manongjc.com/detail/15-nsrwhykxuudfbuv.html)

连接上服务器之后，安装axios和qs，见环境安装-安装axios，环境安装-安装qs。

配置接口请求文件，src下新建utils（方法文件夹），新建request.js文件用于配置请求和响应参数。

```js
import axios from 'axios'
import qs from 'qs'
import store from '@/store'
import { getToken } from '@/utils/auth'

// create an axios instance
const service = axios.create({
  // baseURL: process.env.VUE_APP_BASE_API, // url = base url + request url
  baseURL: '/api_edims/', // 'http://192.168.162.219/EDIMS-WebOwner',
  // baseURL: 'http://192.168.162.30/EDIMS-WebPE',
  withCredentials: true, // send cookies when cross-domain requests
  timeout: 10 * 1000 // request timeout
})

/* request请求拦截器==>对请求参数做处理 */
service.interceptors.request.use(

  config => {
    config.headers['token'] = getToken()
    // 逻辑优化： post时是data，headers不设置时data要qs.stringify转换，headers要设置时data不用转换。get时是params，不需要转换
    // config.method === 'post'?config.data = qs.stringify({...config.data}):config.params = {...config.params}
    if (config.method === 'post') {
      if (config.setHeadersContentType) {
        config.headers['Content-Type'] = 'application/json;charset=UTF-8'
      } else {
        config.data = qs.stringify({...config.data})
      }
    }
    if (config.method === 'get') {
      // 如果是get请求，且params是数组类型如arr=[1,2]，则转换成arr=1&arr=2
      config.paramsSerializer = function(params) {
        return qs.stringify(params, { arrayFormat: 'repeat' })
      }
    }
    /* if(store.state.login.token && config.baseURL != 'http://58.221.7.174:10000'){
        config.headers['token'] = store.state.login.token;
    } */
    return config
},error => {
    // do something with request error
    // console.log(error) // for debug
    Promise.reject(error)
})

/* respone响应拦截器==>对响应做处理 */
service.interceptors.response.use(

  response => {
    // service status code
    const res = response.data
    // console.log(response)
    if (res.status !== 0) {
      // Message({
      //   message: res.msg || 'Error',
      //   type: 'error',
      //   duration: 3 * 1000
      // })

      // Do not block exit operations
      if (response.config.url.indexOf('loginout') !== -1) {
        return res
      }
      // to re-login
      // 'You have been logged out, you can cancel to stay on this page, or log in again'
      if (res.status === 21000) {
        // MessageBox.confirm(res.msg, 'Confirm logout', {
        //   confirmButtonText: 'Re-Login',
        //   cancelButtonText: 'Cancel',
        //   type: 'warning'
        // }).then(() => {
        //   // reset user token and reload.
        //   store.dispatch('user/resetToken').then(() => {
        //     location.reload()
        //   })
        // }).catch(() => {
        //   // store.dispatch('user/resetToken').then(() => {
        //   //   location.reload()
        //   // })
        // })

        store.dispatch('user/clearLoginToken').then(() => {
          // location.reload()
        })

        // store.dispatch('user/resetToken').then(() => {
        //   location.reload()
        // })
      }
      return res
      // return Promise.reject(new Error(res.msg || 'Error'))
    } else {
      // Promise.reject();
      return res
    }
  }
  ,error =>{
    console.log(error)
    return Promise.reject(error)
  }
)

export default service
```

然后是编写接口调用的格式，*src*下新建*api*文件夹用于存放接口，新建`user.js`用于编写用户相关的接口调用。

接口文件头部引入刚刚配置好的请求配置文件request，以及qs

```js
import request from '@/utils/request.js'
var qs = require('qs')
```

登录接口：

```js
export function login(userName, passWord, rememberMe, vm) { // function名字自定义，传入参数是后台接口需要的请求参数
  var _data = {
    name: userName,
    password: passWord,
    rememberMe: rememberMe
  }
  return request({
    url: '/ajax/token',
    method: 'post',
    data: _data, // 这部分具体接口需要具体设置格式，我在request文件中统一进行了管理，所以不需要在接口分类，只要直接传data就行。
  })
}
```

#### el-input的focus等函数的激活

**需求：**在使用`el-input`组件时，有时需要在其他地方触发输入框的获取焦点功能。Element UI官网对此的介绍十分简陋，但可以通过以下方法查看对应接口的位置：

```vue
// html
<el-input ref="input" />

// js
console.log(this.$refs.input)
```

通过这种方式，打印出`el-input`对应的所有配置，最终，在

```js
this.$refs.input.$children[0].focus()
```

触发获取焦点接口，此外，还有失去焦点：`blur()`，选中 input 中的文字：`select()`等。

#### el-scrollbar细节设置，在不需要滚动条时隐藏

在某些不需要滚动的页面，设置了el-scrollbar之后，鼠标在页面滑动时仍会出现滚动条的底色，要解决这个问题，可以使滚动条底色的透明度为0，即可在不使用时隐藏滚动条。

```scss
.el-scrollbar__bar{
  &.is-vertical{ //竖直的滚动条，宽度为厚度
    background: rgba($color: #E6E6E6, $alpha: 0); // 背景色透明度为0，则不需要时隐藏滚动条
    width:4px; // 滚动条宽度
    // opacity: 0.8;
  }
}
```

#### 鼠标移动到弹出子菜单上时，父级菜单的高亮效果消失，如何保持？

需求描述：在导航侧栏中，某些菜单项有子集，当鼠标移动到子集时，父级的高亮样式消失。现在需要保持父级的样式。

- 在父级标签中添加鼠标移入和移出监听`@mouseenter`和`@mouseleave`

- 新建移入移出标记变量`hoverOut: false`

- 分别在移入移出监听方法中写判断条件，移入时`hoverOut = true`，移出后为`false`。

- 父级标签绑定移入样式，以hoverOut的值作为判断。

  ```vue
  <div :class="{hover_enter: hoverOut}">
      <!-- ... -->
  </div>
  ```

- 设置`hover_enter`样式

  ```css
  .hover_enter{
      /* ... */
  }
  ```

  

#### :class时针对不同条件选择不同的样式写法

例如，条件a时选择classA样式，条件b时选择classB样式：

```html
<div :class="{classA:表达式a,classB:表达式b}">
    <!-- ... -->
</div>
```

#### 表格滚动加载数据

对el-table的数据区设置滚动条拉到底部时加载数据。

直接放js：

```js
mounted() {
    this.index = 1
    document.querySelector('.el-table__body-wrapper').addEventListener('scroll', this.onScroll)
},
methods: {
	onScroll() {
      const dom = document.querySelector('.el-table__body-wrapper')
      if (dom.scrollHeight - dom.scrollTop <= dom.clientHeight) {
        this.detailDataLogTable.dataList = this.totalData.slice(0, Math.round(this.totalData.length * 0.1) * ++this.index) // totalData是接口返回的全部数据，存在totalData变量中，detailDataLogTable.dataList是展示出来的数据，当滚动条拉到底部时，将totalData中更多的数据载入detailDataLogTable.dataList中
      }
    }
}
```

这里：`scrollHeight`是滚动框的高度，`scrollTop`是滚动条相对于滚动框顶部的距离，`clientHeight`是滚动条的高度。

#### 导航侧栏的伸缩

**主要参考：**[Vue前端项目-首页-左侧菜单栏的展开与折叠](https://blog.csdn.net/u010559460/article/details/105235469#4%E3%80%81%E6%96%B0%E5%BB%BAapp%E6%A8%A1%E5%9D%97%E7%94%A8%E4%BA%8E%E7%AE%A1%E7%90%86%E6%95%B4%E4%B8%AA%E5%BA%94%E7%94%A8%E7%8A%B6%E6%80%81)

**实现效果：**点击展开按钮，侧栏伸展，出现带图标和文字的详细菜单，右侧主题页面则相应收缩部分；再次点击按钮，侧栏收缩，只剩图标，鼠标悬浮图标，浮现二级菜单等。

**思路：**

- 点击按钮（展开与折叠按钮），触发左侧菜单栏的张开与折叠，需要使用一个变量（**state.sidebar.opened**）来控制
- 为什么要用 **state.sidebar.opened** 全局变量? 原因是按钮组件与侧边栏组件不是父子组件的关系，按钮点击事件改变 **state.sidebar.opened** 值为 true 或 false。侧边栏组件需要读取 **state.sidebar.opened** 来决定自己是要展开还是折叠？
- 左侧 el-menu 组件中有 collapse 属性是控制菜单栏的展开与收缩。我们可以通过 **state.sidebar.opened** 值，来控制 el-menu元素
- 只是设置 el-menu 中 collapse 属性还是不够的, 还需要配置 左边侧边栏的隐藏样式, 通过**state.sidebar.opened** 动态显示样式

**汉堡包组件：**

新建 `src/components/Hamburger/hamburger.vue`文件作为控制伸缩的按钮

绑定点击方法，注意不要在**公共组件**中写入**含有业务性**的内容

```html
<div style="padding: 0 15px;" @click="toggleClick">
```

点击按钮后触发调用父组件方法

```js
toggleClick() {

	this.$emit('toggleClick')

}
```

具体代码：

```vue
<template>
  <div style="padding: 0 15px;" @click="toggleClick">
    <svg
      :class="{'is-active':isActive}"
      class="hamburger"
      viewBox="0 0 1024 1024"
      xmlns="http://www.w3.org/2000/svg"
      width="64"
      height="64"
    >
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM142.4 642.1L298.7 519a8.84 8.84 0 0 0 0-13.9L142.4 381.9c-5.8-4.6-14.4-.5-14.4 6.9v246.3a8.9 8.9 0 0 0 14.4 7z" />
    </svg>
  </div>
</template>
 
<script>
export default {
  name: 'Hamburger',
  props: {
    isActive: {
      type: Boolean,
      default: false
    }
  },
  methods: {
    toggleClick() {
      this.$emit('toggleClick')
    }
  }
}
</script>
 
<style scoped>
.hamburger {
  display: inline-block;
  vertical-align: middle;
  width: 20px;
  height: 20px;
}
 
.hamburger.is-active {
  transform: rotate(180deg);
}
</style>
```

**父组件中调用 Vuex 改变侧边栏状态：**

若将汉堡包按钮放在页面头部，则在 `src /layout/components/app_header.vue` 中

调用汉堡包组件：

```html
<Hamburger class="hamburger-container" :isActive="sidebar.opened" @toggleClick="toggleSideBar" />
```

引入`mapGetters`来获取侧栏的伸缩状态，作为`isActive`参数传给汉堡包组件：

```js
import { mapGetters } from 'vuex'
export default {
    ...
    computed: {
      ...mapGetters([
        'sidebar',
      ])
    },
    ...
}
```

父组件调用 `vuex` 改变**state.sidebar.opened** 的值

```js
toggleSideBar() {
   this.$store.dispatch('app/toggleSideBar')
}
```

具体代码：

```vue
<template>
  <div class="title-bar">
    <div class="left">
      <Hamburger class="hamburger-container" :isActive="sidebar.opened" @toggleClick="toggleSideBar" />
      <svg-icon icon-class="orange" />
      <span class="title-word">Orange!</span>
    </div>

    <div class="right">
      <svg-icon icon-class="user" />
    </div>
  </div>
</template>

<script>
  import { mapGetters } from 'vuex'
  import Hamburger from '@/components/public/Hamburger/hamburger.vue'
  export default {
    name: 'app_header',
    components: {
      Hamburger
    },
    computed: {
      ...mapGetters([
        'sidebar',
      ])
    },
    methods: {
      toggleSideBar() {
        this.$store.dispatch('app/toggleSideBar')
      }
    }
  }
</script>

<style lang="scss" scoped>
  @import '@/assets/styles/elements/variables.scss';

  .title-bar{
    height: $header_height;
    background-color: $header_background_color;
    overflow: hidden;
    color: #fffdeb;
    position: relative;

    .hamburger-container{
      line-height: $header_height;
      height: 100%;
      float: left;
      cursor: pointer;
      transition: background 0.3s;
      -webkit-tap-highlight-color: transparent;

      &:hover {
        background: rgba(0, 0, 0, 0.025);
      }
    }
    .title-word{
      font-size: 50px;
    }
    .left{
      float: left;
      height: 100%;
      border: #000000 1px solid;
    }
    .right{
      float: right;
      width: 180px;
      border: #000000 1px solid;
      height: 100%;
    }
    .svg-icon{
      font-size: 50px;
    }
  }
</style>
```

**在store中新建app模块用于管理整个应用状态:**

新建`src/store/modules/app.js`（若没安装Cookies，移步`项目搭建-细节配置-安装js-cookie`）：

```js
import Cookies from 'js-cookie'

const state = {
  sidebar: {
    opened: Cookies.get('sidebarStatus') ? !!+Cookies.get('sidebarStatus') : true,
    withoutAnimation: false
  }
}

const mutations = {
  TOGGLE_SIDEBAR: state => {
    state.sidebar.opened = !state.sidebar.opened
    state.sidebar.withoutAnimation = false
    if (state.sidebar.opened) {
      Cookies.set('sidebarStatus', 1)
    } else {
      Cookies.set('sidebarStatus', 0)
    }
  },
  CLOSE_SIDEBAR: (state, withoutAnimation) => {
    Cookies.set('sidebarStatus', 0)
    state.sidebar.opened = false
    state.sidebar.withoutAnimation = withoutAnimation
  }
}

const actions = {
  toggleSideBar({ commit }) {
    commit('TOGGLE_SIDEBAR')
  },
  closeSideBar({ commit }, { withoutAnimation }) {
    commit('CLOSE_SIDEBAR', withoutAnimation)
  }
}

export default {
  namespaced: true, // namespaced: true 的方式使其成为带命名空间的模块。保证在变量名一样的时候，添加一个父级名拼接。
  state,
  mutations,
  actions
}

```

**侧栏实现：**

新建`src/layout/components/side_nav_bar.vue`文件

通过绑定`el-menu`的`collapse`属性控制侧栏伸缩：

```html
<el-menu :collapse="isCollapse" />
```

`isCollapse`方法：

```js
isCollapse() {
    return !this.sidebar.opened
}
```

`activeMenu`方法用于获取当前路由从而映射到侧栏对应的菜单项：

```js
activeMenu() {
    const route = this.$route
    const { meta, path } = route
    // if set path, the sidebar will highlight the path you set
    if (meta.activeMenu) {
      return meta.activeMenu
    }
    return path
}
```

注意：侧栏收缩时可能会遇到文字在收缩之后才消失的问题，需要设置折叠动画为`false`即可解决。

`:collapse-transition="false"`

具体代码：

```vue
<template>
  <div class="app-aside">
    <el-scrollbar>
      <el-menu
        :default-active="activeMenu"
        :collapse="isCollapse"
        :collapse-transition="false"
        mode="vertical"
      >
        <el-submenu index="1">
          <template slot="title">
            <svg-icon icon-class="home"></svg-icon>
            <span slot="title">首页</span>
          </template>
          <el-menu-item index="1-1">选项1</el-menu-item>
          <el-menu-item index="1-2">选项2</el-menu-item>
        </el-submenu>

        <el-submenu index="2">
          <template slot="title">
            <svg-icon icon-class="setting"></svg-icon>
            <span slot="title">设置</span>
          </template>
          <el-menu-item index="2-1">选项3</el-menu-item>
          <el-menu-item index="2-2">选项4</el-menu-item>
        </el-submenu>
      </el-menu>
    </el-scrollbar>
  </div>
</template>

<script>
  import { mapGetters } from 'vuex'
  export default {
    name: 'side_nav_bar',
    data() {
      return {
      }
    },
    methods: {

    },
    computed: {
      ...mapGetters([
        'sidebar',
      ]),
      activeMenu() {
        const route = this.$route
        const { meta, path } = route
        // if set path, the sidebar will highlight the path you set
        if (meta.activeMenu) {
          return meta.activeMenu
        }
        return path
      },
      variables() {
        return variables
      },
      isCollapse() {
        return !this.sidebar.opened
      }
    }
  }
</script>

<style lang="scss" scoped>
  /deep/.app-aside{
    /deep/.svg-icon{
      font-size: 20px;
    }
  }
</style>

```

**设置全局通用的样式属性值：**

新建 `src/assets/styles/elements/variables.scss` 文件

```js
// layout
$header_height: 60px;
$header_background_color: #ffd787;

$footer_height: 60px;

$side_nav_bar_width: 110px;
$side_nav_bar_hidden_width: 64px;

:export {
  header_height: $header_height;
  header_background_color: $header_background_color;
  footer_height: $footer_height;
  side_nav_bar_width: $side_nav_bar_width;
  side_nav_bar_hidden_width: $side_nav_bar_hidden_width;
}
```

然后在`src/assets/styles/index.scss` 文件引用它：

```scss
@import './elements/variables.scss';
@import './elements/sidebar.scss';

body{
  margin: 0;
  padding: 0;
  height: 100%;
}

```

> 详细使用方法移步`项目搭建-细节配置-外部调用scss文件`

**设置侧栏收缩时的样式：**

在 `src/assets/styles/elements/sidebar.scss` 中, 设置样式

```scss
#app {
  .main-wrapper {
    min-height: 100%;
    transition: margin-left .28s;
    width: calc(100% - #{$side_nav_bar_width});
    margin-left: $side_nav_bar_width;
    position: relative;
  }

  .sidebar-container {
    // transition: width 0.28s;
    width: $side_nav_bar_width !important;
    // height: 100%;
    position: fixed;
    font-size: 0px;
    // top: 0;
    bottom: 0;
    left: 0;
    overflow: hidden;

    .scrollbar-wrapper {
      height: 100%;
      overflow-x: hidden !important;

      .el-scrollbar__wrap {
        overflow-x: hidden !important;
      }

      a {
        display: inline-block;
        width: 100%;
        overflow: hidden;
        text-decoration: none;
      }
      .el-menu {
        border: none;
        height: 100%;
        width: 100% !important;
      }

      .svg-icon {
        margin-right: 16px;
      }

    }
  }

  .hideSidebar {
    .sidebar-container {
      width: $side_nav_bar_hidden_width !important;
    }

    .main-wrapper {
      margin-left: $side_nav_bar_hidden_width;
    }

    .submenu-title-noDropdown {
      padding: 0 !important;
      position: relative;

      .el-tooltip {
        padding: 0 !important;

        .svg-icon {
          margin-left: 20px;
        }
      }
    }

    .el-submenu {
      overflow: hidden;

      &>.el-submenu__title {
        padding: 0 !important;

        .svg-icon {
          margin-left: 20px;
        }

        .el-submenu__icon-arrow {
          display: none;
        }
      }
    }

    .el-menu--collapse {
      .el-submenu {
        &>.el-submenu__title {
          &>span {
            height: 0;
            width: 0;
            overflow: hidden;
            visibility: hidden;
            display: inline-block;
          }
        }
      }
    }
  }

}

```

**在layout中添加class绑定：**

template标签下的div添加class绑定：

```html
<template>
  <div :class="classObj" class="app-wrapper">
    ...
  </div>
</template>
```

computed中监听classObj属性：

```js
classObj() {
    return {
      hideSidebar: !this.sidebar.opened,
    }
}
```

完整代码：

```vue
<!-- layout.vue -->

<template>
  <div :class="classObj" class="app-wrapper">
    <el-container>
      <Sidebar class="sidebar-container" />
      <el-container direction="vertical"  class="main-wrapper">
        <el-header :height="variables.header_height">
          <Header />
        </el-header>
        <el-main>
          <AppMain />
        </el-main>
        <el-footer>
          <Footer />
        </el-footer>
      </el-container>
    </el-container>
  </div>
</template>

<script>
  import { mapState } from 'vuex'

  import Sidebar from './components/side_nav_bar.vue'
  import Header from './components/app_header.vue'
  import AppMain from'./components/app_main.vue'
  import Footer from './components/app_footer.vue'

  import variables from '@/assets/styles/elements/variables.scss'
  export default {
    name: 'Layout',
    components: {
      Sidebar,
      Header,
      AppMain,
      Footer
    },
    computed: {
      ...mapState({
        sidebar: state => state.app.sidebar,
      }),
      classObj() {
        return {
          hideSidebar: !this.sidebar.opened,
        }
      },
      variables() {
        return variables
      }
    },
    methods: {

    }
}
</script>

<style lang="scss" scoped>
  @import '@/assets/styles/elements/variables.scss';

  *{
    padding: 0;
  }
  .app-wrapper .el-header{
    /* background: rgba(0, 0, 0, 0.1); */
    position: fixed;
    top: 0;
    z-index: 9999;
    overflow: hidden;
    width: 100%;
  }
  .app-wrapper .el-main{
    /* background: rgba(255, 0, 0, 0.1); */
    margin: $header_height 0 0 0;
    min-height: calc(100vh - #{$header_height} - #{$footer_height}); /*最小高度=屏幕高度-(头部高度+尾部高度)*/
  }
  .app-wrapper .el-footer{
    background: rgba(150, 150, 150,0.1);
    // position: absolute;
    width: 100%;
    bottom: 0;
  }
</style>
```

#### Vuex中模块化的引入

比如要对整个系统的状态进行模块化管理，在`store`文件夹下新建`modules`文件夹，用于进行系统的模块化管理。

对整个应用进行的状态管理，可在modules文件夹下新建*app.js*文件，并编写相应的`state`，`mutations`，`actions`，然后`export`出去。

```js
// app.js
const state = {
  ...
}
const mutations = {
  ...
}
const actions = {
  ...
}
    
export default {
    namespaced: true // namespaced: true 的方式使其成为带命名空间的模块。保证在变量名一样的时候，添加一个父级名拼接。
    state,
    mutations,
    actions
}
```

**引入模块化文件：**

不需要逐个文件引入，在store/index.js文件中

```js
// https://webpack.js.org/guides/dependency-management/#requirecontext
const modulesFiles = require.context('./modules', true, /\.js$/)

// you do not need `import app from './modules/app'`
// it will auto require all vuex module from modules file
const modules = modulesFiles.keys().reduce((modules, modulePath) => {
  // set './app.js' => 'app'
  const moduleName = modulePath.replace(/^\.\/(.*)\.\w+$/, '$1')
  const value = modulesFiles(modulePath)
  modules[moduleName] = value.default
  return modules
}, {})
```

再通过getters即可自动引入modeles文件夹下的模块文件，完整代码：

```js
// index.js

import Vue from 'vue'
import Vuex from 'vuex'
import getters from './getters'

Vue.use(Vuex)

// https://webpack.js.org/guides/dependency-management/#requirecontext
const modulesFiles = require.context('./modules', true, /\.js$/)

// you do not need `import app from './modules/app'`
// it will auto require all vuex module from modules file
const modules = modulesFiles.keys().reduce((modules, modulePath) => {
  // set './app.js' => 'app'
  const moduleName = modulePath.replace(/^\.\/(.*)\.\w+$/, '$1')
  const value = modulesFiles(modulePath)
  modules[moduleName] = value.default
  return modules
}, {})

const store = new Vuex.Store({
  modules,
  getters
})

export default store

```

新建store/getters.js:

```js
// getters.js

const getters = {
  sidebar: state => state.app.sidebar,
  language: state => state.app.language,

  size: state => state.app.size,
  device: state => state.app.device,

  visitedViews: state => state.tagsView.visitedViews,
  cachedViews: state => state.tagsView.cachedViews,

  token: state => state.user.token,
  // avatar: state => state.user.avatar,
  name: state => state.user.name,

  // introduction: state => state.user.introduction,
  // roles: state => state.user.roles,

  // permission_routes: state => state.permission.routes,
  errorLogs: state => state.errorLog.logs
}
export default getters

```

**使用模块中的mutations、getters、actions时候，要加上模块名，例如使用commint执行mutations时**

格式：模块名/模块中的`mutations`
`'xxx/setUserInfo'`

```js
this.$store.commit("userInfo/setUserInfo",userInfo)
```

**获取属性时同样加上模块名**

格式：`store.state.模块名.模块属性`
`$store.state.userInfo.userName`

#### 外部调用scss文件

script标签中：

```vue
<script>
    import variables from '文件路径/variables.scss'
    ...
    computed: {
    	variables() {
      		return variables
    	}
  	}
</script>
```

使用：

```vue
<template>
    <div :height="variables.height">
        ...
	</div>
</template>
```

style标签中：

```vue
<style>
    @import '文件路径';
    .class-name{
        height: $height;
        min-height: calc(100% - #{$height}) /*在calc中调用时要用#{}扩起来*/
    }
</style>
```



#### 图片路径的拼接和调用

```html
<!-- 普通用法，直接写入地址 -->
<img src="./img1.png" />

<!-- 路径拼接 -->
<img src="['./' + 'img1.png']" />

<!-- 调用+路径拼接 -->
<img src="['./' + imgName + '.png']" />
```



#### el-button点击之后的样式

```css
.el-button:focus{
	/*something*/
}
```

#### data中，某个数据的值需要复制data里的另一个数据的写法

**问题描述：**

```js
data() {
	return {
		a: this.b, // 这种写法是取不到a的
    	b: []
	}
}
```

**正确做法：**

```js
// 在b赋值的地方也给a赋值
methods: {
	getData() {
		b = this.getArray()
		a = this.getArray()
	},
	getArray() {
		return [1, 2, 3]
	}
}
```



#### 通过a对象中某属性的值来定位到b属性中对应字段属性的值

假设现在定义了两个对象a和b

```js
a = {
  index: 'name2',
},
b = {
  name1: 'obj1',
  name2: 'obj2',
  name3: 'obj3'
}
```

现在我需要通过a对象中`index`属性的值来定位到b属性中对应的值
即：`b.(a.index)`，相当于：`b.name2`，使其能够输出字符串：`'obj2'`

**解决方法：**事实上，想直接写`b.(a.index)`类似这种语法是不能实现的。
可以通过`v-for`循环加`v-if`筛选来实现这种功能。
PS：第二天，我就发现可以实现了。。。**中括号**就行了。。。`b.[a.index]`

```vue
<div v-for="(i, index) in b" :key="index">
	<p v-if="index==a.index">{{ i }}</p>
</div>
```

在`v-for`循环中，`i`代表对象`b`中每个属性的值，即：`obj1`，`obj2`，`obj3`。而**index**代表的是对象`b`中属性名称，即：`name1`，`name2`，`name3`。由此，可以实现通过对象`a`某属性（`index`）的值（`name2`）作为字段来获取对象`b`中对应的值（`b.name2`）。

#### 样式选择器名称注意事项

在调整样式中，名称里各部分之间的位置注意事项。

```css
.el-table {
	/*这是对el-table单样式的设置*/
}
.el-table th {
	/*对el-table下的th样式进行设置*/ /*名称之间空格连接*/
}
.el-table#elementId { /*#号代表id，.号代表类*/
	/*对id名称为“elementId”的el-table的样式进行设置*/ /*名称之间紧挨无空格*/
}
```



#### 对多个样式同时进行修改

注意区分

```css
/*这是对a样式下或a样式里面包含的b样式的修改*/
.a .b{
	/*something*/
}
/*这是对a样式和b样式做同步同样的修改*/
.a ,.b{
	/*something*/
}
```



#### 样式中对“最后一项”的设置

在`el-table`中，需要对表头的**最后一项**样式做特殊处理，使用`:last-child`或`:nth-last-child(n)`字段进行选取。其中，要特别注意该字段出现的**顺序**而且字段要紧跟前面的内容，**不能有空格**，否则可能无法选到正确的位置。例如：

```scss
//总体样式
.el-table th > .cell{
  border-right: 1px solid #ffffff;
}
//最后一项的样式
.el-table th:nth-last-child(1) > .cell{
  border-right: none;
}
//而不是
.el-table th > .cell:nth-last-child(1){
  border-right: none;
}
//倒数第二项
.el-table th:nth-last-child(2) > .cell{
  border-right: none;
}
```



#### svg图片大小设置

在标签内设置其**字体大小font-size**即可改变图片大小

#### vue项目中scss文件引入

命令行安装插件

```
npm install node-sass --save-dev 
```

```
npm install sass-loader --save-dev
```

安装完后可能会识别不了，报错The "path" argument must be of type string.
原因是`sass-loader`版本问题，在工程目录下找到`package.json`文件，此时`sass-loader`版本为^10.0.3，改为^7.3.0，然后重新安装依赖，命令行输入：

```
cnpm i
```

即可。

#### vue项目中建立全局样式文件及修改Element UI样式

1. 在`assets`文件夹下新建styles文件夹，然后在styles文件夹下新建`index.scss`（**全局样式**）文件及`elements`文件夹（用于存放**Element UI样式**）
   |--assets
   |  |--styles
   |  |  |--elements(Element UI样式文件夹)
   |  |  |  |--element-ui.scss(Element UI样式)

   |  |  |--index.scss(全局样式)

2. `index.scss`文件中引入Element样式文件

   ```scss
   @import './elements/element-ui.scss';
   ```

3. `element-ui.scss`中设置Element样式（注意这里是**全局范围**）

4. 在工程的`main.js`文件中引入样式文件

   ```js
   import '@/assets/styles/index.scss'
   ```

#### 页面整体缩放问题

各组件采用百分比设置大小，即可随页面一起缩放。

#### 接口返回时间差和展示的问题

如果要传递的数据更新时，需要刷新组件才能更新视图，那么可以在组件中写watch监听，当监听的数据发生变化时刷新视图。

#### vue项目中引入字体

1. 下载字体的`.ttf`格式文件

2. 项目中，assets文件夹下新建font文件夹，并创建*font.css*文件，将下载的字体文件也放入font文件夹。

3. 在*font.css*文件中编写：

   ```css
   @font-face {
     font-family: 'PingFang-SC-Bold'; /*项目中要引用的字体名称*/
     src: url('PingFang-SC-Bold.ttf'); /*字体文件名*/
     font-weight: normal;
     font-style: normal;
   }
   ```

4. 在项目的*main.js*文件中引入

   ```js
   import '@/assets/font/font.css'
   ```

5. 页面中即可使用引入的新字体

   ```css
   <style scoped>
   	.class-name{
   		font-family: 'PingFang-SC-Bold'
   	}
   </style>
   ```

#### el-table的滚动条

不需要在table外部扩<el-scrollbar>，直接在该页面的样式下设置

```scss
>>>.el-table__body-wrapper::-webkit-scrollbar{ /*滚动条空白部分的颜色,好像没什么用*/
  /* background-color: #000000; */
  height: 10px;
}
>>>.el-table__body-wrapper::-webkit-scrollbar-thumb{ /*滚动管子的颜色*/
  background-color: rgba(48, 71, 198, 1);
  /* linear-gradient(#e66465, #9198e5) */
  border-radius: 20px;
}
>>>.el-table__body-wrapper::-webkit-scrollbar-track{ /*滚动轨道的颜色*/
  /* background-color: #3047C6; */
  background-color: #E6E6E6;
  border-radius: 20px;
}
```



#### 滚动条

Element UI官网是没有滚动条的介绍的。

如果要在`id="a"的`div`中使用el-scrollbar，那么就要在<div id="a">标签下立刻使用<el-scrollbar>，中间不要有内容，否则会出现格式错乱。

```css
<div id="a">
	<el-scrollbar>
		content...
	</el-scrollbar>
</div>
```

**el-scrollbar**

```scss
.el-scrollbar{
  height: 100%; // 一定要设置高度为100%
}
.el-scrollbar__wrap{
  overflow-y: auto;
  overflow-x:hidden;
}
.el-scrollbar__bar{ // 这一项要在el-scrollbar的样式外层
  &.is-vertical{ //竖直的滚动条，宽度为厚度
    background: rgba($color: #E6E6E6, $alpha: 1.0); // 如果要滚动条不使用时不出现，将该项透明度改为0
    width:4px; // 滚动条宽度
    opacity: 1;
  }
}
.el-scrollbar__thumb { // 滚动管子的样式
  // 可设置滚动条颜色
  background: rgba($color: #3047C6, $alpha: 1.0);
  border-radius: 2px;
}
.el-scrollbar__thumb:hover{
  background: rgba($color: #3047C6, $alpha: 1.0);
}
```

#### 定时器

有定时器/计时器的页面，一定要设置关闭页面时的定时器清除。

```js
beforeDestroy() {
    this.$once('hook:beforeDestroy', () => {
      clearTimeout(this.timer)
      this.timer = null
    })
 },
```

#### Element UI默认样式修改

- 可以在Element公共样式中修改，但那样会改变全局的样式。
- 在单个页面下，<style>的scoped属性去掉，为了避免设置为全局样式，在样式前面加上父级标签的类名/id，例如：

```css
<style>
.detail .el-tabs__nav-scroll {
  overflow: hidden;
  background-color: #000000;
}
.tab-sheet .el-tabs__nav-scroll {
  background-color: #ffffff;
}
</style>
```



#### svg图标动态修改颜色

https://www.iconfont.cn/

在阿里巴巴图标库下载svg文件并放入svg文件夹后，想要改变颜色，需要进入该图片文件，搜索字段`fill`，将该属性删除，即可修改图片的颜色。

#### 在项目中使用Svg图标

https://www.cnblogs.com/shenyf/p/10370949.html

**调用格式：**

```vue
<svg-icon icon-class="filter"></svg-icon>
```

#### 使用Element UI自定义主题

在官方网站主题编辑器编辑自定义颜色，下载包解压在工程文件根目录下，然后在main.js中引入theme下的index.css即可。（该方法再次启动项目时会报错，详情移步/vue/报错）

#### 去掉vue-cli新建项目的默认白边

在App.vue中加上

```css
*{
margin: 0;
padding: 0;
}
```

#### 项目运行自启动浏览器

在config配置文件中，找到`autoOpenBrowser: false,`改为`true`即可。

#### 项目图标

**图标文件名称格式一定要是favicon.ico！！**

favicon图标的配置也很简单，vue-cli默认帮我们安装了`html-webpack-plugin`（如果没有，可以自己npm安装），我们只需在`html-webpack-plugin`插件中添加`favicon`选项即可。`html-webpack-plugin`插件需要配置两处，一处是在开发环境下配置，另一处是在打包后的环境下配置，如果只配置开发环境下的，没有配置打包后环境的，造成的结果就是，项目本地运行时会有favicon图标，打包后放在服务器上时发现没有favicon图标；反之亦然。详细配置如下：

1. **开发环境（开发调试时）配置：**
   build下的webpack.dev.conf.js文件的plugins设置：

   ```js
   new HtmlWebpackPlugin({
         filename: 'index.html',
         template: 'index.html',
         favicon: 'src/assets/chengzi.ico',
         inject: true
       }),
   ```

2. **生产环境（打包后）配置：**
   build下的webpack.prod.conf.js文件的plugins设置：

   ```js
   new HtmlWebpackPlugin({
         filename: 'index.html',
         template: 'index.html',
         favicon: 'src/assets/chengzi.ico',
         inject: true
       }),
   ```

**注意：配置favicon图标的路径是相对路径！！！**

------

## Web

### console的使用

1. **`console.table`表格形式打印**
   `console.log`是我们最常用的打印方法，但是在打印一些比较复杂的数据时候，我们浏览起来就会显得很费力。比如：
   ![](https://img-blog.csdnimg.cn/20200621223744421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTg2ODk1,size_16,color_FFFFFF,t_70)
   而使用console.table打印就会自动生成表格，使打印结果看起来更加清晰易懂：
   ![](https://img-blog.csdnimg.cn/20200621223811184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTg2ODk1,size_16,color_FFFFFF,t_70)
2. **`console.dir`打印对象**`console.dir`与`console.log`不同之处在于，前者可以递归打印对象的所有属性，而后者侧重于字符串化的打印。比如要打印一个DOM节点。
   ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200621224230168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTg2ODk1,size_16,color_FFFFFF,t_70)
   `console.log`只是把html节点打印出来，而`console.table`把DOM对象的所有属性打印出来。
3. **`console.log`附带样式打印**细心的朋友可能会发现许多网站会在Chrome控制台打印许多提示信息，而且还附带样式，看起来非常的惊艳。比如天猫：
   ![在这里插入图片描述](https://img-blog.csdnimg.cn/2020062122474174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTg2ODk1,size_16,color_FFFFFF,t_70)
   但是样式具体要怎么打印呢。
   其实很简单，只需要在打印的字符串前加上%c就可以添加样式了。![在这里插入图片描述](https://img-blog.csdnimg.cn/20200621225040388.png)
   还可以通过%s,%d等插入数据，和C语言printf相似。
   ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200621225343661.png)
4. **`console.trace`追踪函数调用**`console.trace()` 方法用于显示当前执行的代码在堆栈中的调用路径。通过在某个方法中打印一些信息，可以快速定位到该方法所在的文件和文件内具体位置，以及查看函数的调用栈。
   ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200622111940684.png)![在这里插入图片描述](https://img-blog.csdnimg.cn/20200622112056179.png)
5. **`console.assert`条件打印**assert方法接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。比如：
   ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200622171811345.png)
   例子中就只输出了条件不成立，而且用红色警示展示。
6. **`console.count`技术打印**相信在平时我们开发经常会去测试一些代码执行的次数，一般我们都会声明一个变量记录次数，最后`console.log`打印结果，其实浏览器内置给我们提供了这种方法。
   ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200622172412302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTg2ODk1,size_16,color_FFFFFF,t_70)
7. **`console.time`和`console.timeEnd`计时打印**计时也是非常好用的一种打印方法，为了性能优化，我们可能经常定位一些执行时间较长的代码段，平时很多人会通过`Date.now()`计算，但其实浏览器也为我们提供好了这种方法，不仅方便好用而且时间也是格式化好的。
   ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200622173600770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTg2ODk1,size_16,color_FFFFFF,t_70)

### svg图标的动画效果

可以自行绘制`svg`图标，并且定义简单的动画效果，然后保存为`svg`文件。下面简单介绍代码并附例子。

`svg`文件头部标签`<?xml version="1.0" encoding="utf-8"?>`

`svg`文件用<svg>标签包裹，内联`style`属性设置样式，其中`width`和`height`设置图标的大小（宽高），`viewbox`属性设置可见范围。

**图形**

<circle>标签用于在图标中画出一个圆，`cx`是圆心x坐标（相对于左上角）`cy`是圆心y坐标（相对于左上角）`fill`为图标填充的颜色，`r`是半径。

另外的形状有：

- 矩形 <rect>
- 圆形 <circle>
- 椭圆 <ellipse>
- 线 <line>
- 折线 <polyline>
- 多边形 <polygon>
- 路径 <path>

**图层覆盖规则**

图层的覆盖取决于**定义图形的顺序，后定义图形的图层高于先定义的**，例如先定义了一个`circle圆1`，再在`圆1`下面定义一个`circle圆2`，则`圆2`图层在`圆1`之上，若运动过程中`圆1圆2`有重合，则`圆1`会被`圆2`覆盖。

**动画效果**

目前仅记录了简单的动画效果。

例如，要让定义的circle动起来，那么就在<circle>标签内，定义<animate>标签，代表定义某一属性的变化过程。如果希望多个属性同时变化，那么定义多个<animate>标签即可。

|      属性       |                             作用                             |
| :-------------: | :----------------------------------------------------------: |
| `attributeName` |                    要变化的属性，例如`cx`                    |
|  `repeatCount`  |              重复次数，无限重复：`"indefinite"`              |
|      `dur`      |               一次动画的持续时间，例如`1.5s`。               |
|   `keyTimes`    | 定义阶段性时间点，**取值范围为[0,1]**，可以有多个值，**分号分隔**，例如：`0;0.5;1`。 |
|    `values`     | 与阶段性时间点匹配的值，例如要变化`cx`，可以定义values的值为：`10;50;10`，表示该图形从`10`坐标位置横向移动到`50`又回到了`10`。 |
|     `begin`     |                        动画开始时间。                        |

**例子**

一个简单的类似星球环绕的例子，注意行星（蓝色）透明度的变化，以实现运行中被遮挡的效果。

```svg
<?xml version="1.0" encoding="utf-8"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="margin: auto; background: none; display: block; shape-rendering: auto;" width="203px" height="203px" viewBox="0 0 120 120" preserveAspectRatio="xMidYMid">
<circle cx="68" cy="86" fill="blue" r="8">
  <animate attributeName="cx" repeatCount="indefinite" dur="1.5s" keyTimes="0;0.25;0.5;0.75;1" values="68;68;32;32;68" begin="-0.5882352941176471s"></animate>
  <animate attributeName="cy" repeatCount="indefinite" dur="1.5s" keyTimes="0;0.25;0.5;0.75;1" values="86;50;50;86;86" begin="-0.5882352941176471s"></animate>
  <animate attributeName="opacity" repeatCount="indefinite" dur="1.5s" keyTimes="0;0.25;0.5;0.75;1" values="1;1;1;0;0" begin="-0.5882352941176471s"></animate>
</circle>
<circle cx="32" cy="50" fill="red" r="18">
  <animate attributeName="cx" repeatCount="indefinite" dur="1.5s" keyTimes="0;0.25;0.5;0.75;1" values="32;68;68;32;32" begin="-0.5882352941176471s"></animate>
  <animate attributeName="cy" repeatCount="indefinite" dur="1.5s" keyTimes="0;0.25;0.5;0.75;1" values="50;50;86;86;50" begin="-0.5882352941176471s"></animate>
</circle>
<circle cx="68" cy="86" fill="blue" r="8">
  <animate attributeName="cx" repeatCount="indefinite" dur="1.5s" keyTimes="0;0.25;0.5;0.75;1" values="68;68;32;32;68" begin="-0.5882352941176471s"></animate>
  <animate attributeName="cy" repeatCount="indefinite" dur="1.5s" keyTimes="0;0.25;0.5;0.75;1" values="86;50;50;86;86" begin="-0.5882352941176471s"></animate>
  <animate attributeName="opacity" repeatCount="indefinite" dur="1.5s" keyTimes="0;0.25;0.5;0.75;1" values="0;0;0;1;1" begin="-0.5882352941176471s"></animate>
</circle>
</svg>
```

将文件保存为`.svg`格式，双击可以查看效果。

### script标签在html中的位置

一般<script>会放在头部，即<head>标签内；或者放在尾部，即</body>标签之上。放在</body>标签后的<script>在HTML2.0后也会被编译为</body>内部，因此没有区别。

**头部时：**表示在页面dom元素加载完之前，js脚本已经执行完了。**这个位置的js适合做一些全局定义且后期不怎么变化的事情。**

**尾部时：**表示这里的js在页面加载结束之后才执行。

### HTML精确定位

- scrollHeight: 获取对象的滚动高度，应该是该对象可滚动的高度距离，相当于该对象的height。
- scrollLeft:设置或获取位于对象左边界和窗口中目前可见内容的最左端之间的距离，并不是指浏览器窗口，而是指滚动包裹的容器。
- scrollTop:设置或获取位于对象最顶端和窗口中可见内容的最顶端之间的距离。

### 占位符

- &#32 == 普通的英文半角空格
- &#160 == &nbsp == &#xA0 == no-break space （普通的英文半角空格但不换行）
- &#12288 == 中文全角空格 （一个中文宽度）
- &#8194 == &ensp == en空格 （半个中文宽度）
- &#8195 == &emsp == em空格 （一个中文宽度）
- &#8197 == 四分之一em空格 （四分之一中文宽度）

### 常见的浏览器前缀

| 前缀     | 组织      | 示例                   | 说明                                                         |
| -------- | --------- | ---------------------- | ------------------------------------------------------------ |
| -ms-     | Microsoft | -ms-interpolation-mode | IE浏览器专属的CSS属性需添加-ms-前缀                          |
| -moz-    | Mozilla   | -moz-read-only         | 所有基于Gecko引擎的浏览器（如Firefox）专属的CSS属性需添加-moz-前缀 |
| -o-      | Opera     | -o-text-overflow       | Opera浏览器专属的CSS属性需添加-o-前缀                        |
| -webkit- | Webkit    | -webkit-box-shadow     | 所有基于Webkit引擎的浏览器（如Chrome、Safari）专属的CSS需添加-webkit-前缀 |



### Argumens对象

**`arguments`** 是一个对应于传递给函数的参数的类数组对象。

```js
function func1(a, b, c) {
  console.log(arguments[0]);
  // expected output: 1

  console.log(arguments[1]);
  // expected output: 2

  console.log(arguments[2]);
  // expected output: 3
}

func1(1, 2, 3);
```

`arguments`对象是所有（非箭头）函数中都可用的**局部变量**。你可以使用`arguments`对象在函数中引用函数的参数。此对象包含传递给函数的每个参数，第一个参数在索引0处。例如，如果一个函数传递了三个参数，你可以以如下方式引用他们：

```js
arguments[0]
arguments[1]
arguments[2]
```

参数也可以被设置：

```
arguments[1] = 'new value';
```

`arguments`对象不是一个 [`Array`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array) 。它类似于`Array`，但除了length属性和索引元素之外没有任何`Array`属性。例如，它没有 [pop](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/pop) 方法。但是它可以被转换为一个真正的`Array`：

```
var args = Array.prototype.slice.call(arguments);
var args = [].slice.call(arguments);

// ES2015
const args = Array.from(arguments);
const args = [...arguments];
```

### 正则表达式

**语法**

```
/正则表达式主体/修饰符（可选）
```

**修饰符**

| 修饰符 | 描述                                                     |
| :----: | :------------------------------------------------------- |
|   i    | 执行对大小写不敏感的匹配。                               |
|   g    | 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。 |
|   m    | 执行多行匹配。                                           |

**正则表达式模式**

| 表达式 | 描述                                               |
| :----- | :------------------------------------------------- |
| [abc]  | 查找方括号之间的任何字符。                         |
| [0-9]  | 查找任何从 0 至 9 的数字。                         |
| (x\|y) | 查找任何以 \| 分隔的选项。                         |
| {1-4}  | 中括号表示所选内容，花括号表示所选个数，例如1到4个 |

**元字符**是拥有特殊含义的字符：

| 元字符 | 描述                                                         |
| :----: | :----------------------------------------------------------- |
|   \d   | 查找数字。                                                   |
|   \s   | 查找空白字符。                                               |
|   \b   | 匹配单词边界。                                               |
| \uxxxx | 查找以十六进制数 xxxx 规定的 Unicode 字符。                  |
|   \w   | 匹配单词字符，等价于 `[a-zA-Z0-9_]` 共63个字符（字母数字下划线）。 |
|   \S   | 匹配所有非空白。                                             |
|  ^和$  | 标识起止位置，带该两符号的表达式严格限制表达式起止内容。例如：`/a/`和`/^a$/`，判断同样的字符串`'aa'`时，`/a/`的意思是“判断字符串中是否有字符a”；而/^a$/的意思是“从字符串开始到结束是否只有一个字符a” |

**量词**:

| 量词 | 描述                                  |
| :--: | :------------------------------------ |
|  n+  | 匹配任何包含至少一个 *n* 的字符串。   |
|  n*  | 匹配任何包含零个或多个 *n* 的字符串。 |
|  n?  | 匹配任何包含零个或一个 *n* 的字符串。 |

**字符串方法**

**search()**

```js
var str = "Visit Runoob!"; 
var n = str.search(/Runoob/i);
// 6
```

**replace()**

```js
var str = 'Visit Microsoft!'; 
var txt = str.replace(/microsoft/i,"Runoob");
// Visit Runoob!
```



### HTTP请求中request payload和formData的区别

`FormData`和`Payload`是浏览器传输给接口的两种格式，这两种方式浏览器是通过**Content-Type**来进行区分的([了解Content-Type](http://www.cnblogs.com/tugenhua0707/p/8975121.html))，**如果是 application/x-www-form-urlencoded的话，则为formdata方式，如果是application/json或multipart/form-data的话，则为 request payload的方式**。

1、比如使用ajax方式的提交post请求的代码（默认使用application/x-www-form-urlencoded编码）

**2、使用 multipart/form-data表单上传文件**

### JS获取当前网页大小以及屏幕分辨率等

| 参数及意义                                                   |
| ------------------------------------------------------------ |
| 网页可见区域宽：document.body.clientWidth                    |
| 网页可见区域高：document.body.clientHeight                   |
| 网页可见区域宽：document.body.offsetWidth (包括边线和滚动条的宽) |
| 网页可见区域高：document.body.offsetHeight(包括边线的宽)     |
| 网页正文全文宽：document.body.scrollWidth                    |
| 网页正文全文高：document.body.scrollHeight                   |
| 网页被卷去的高：document.body.scrollTop                      |
| 网页被卷去的左：document.body.scrollLeft                     |
| 网页正文部分上：window.screenTop                             |
| 网页正文部分左：window.screenLeft                            |
| 屏幕分辨率的高：window.screen.height                         |
| 屏幕分辨率的宽：window.screen.width                          |
| 屏幕可用工作区高度：window.screen.availHeight                |
| 屏幕可用工作区宽度：window.screen.availWidth                 |
| 屏幕设置 window.screen.colorDepth 位彩色                     |
| 屏幕设置 window.screen.deviceXDPI 像素/英寸                  |

### sessionStorage会话存储

- sessionStorage.key(int index) ：返回当前 sessionStorage 对象的第index序号的key名称。若没有返回null。
- sessionStorage.getItem(string key) ：返回键名(key)对应的值(value)。若没有返回null。
- sessionStorage.setItem(string key, string value) ：该方法接受一个键名(key)和值(value)作为参数，将键值对添加到存储中；如果键名存在，则**更新**其对应的值。
- sessionStorage.removeItem(string key) ：将指定的键名(key)从 sessionStorage 对象中移除。
- sessionStorage.clear() ：清除 sessionStorage 对象所有的项。





### statusCode

201-206都表示服务器成功处理了请求的状态代码，说明网页可以正常访问。

| 返回码            | 含义                                                         |
| ----------------- | :----------------------------------------------------------- |
| 200（成功）       | 服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。 |
| 201（已创建）     | 请求成功且服务器已创建了新的资源。                           |
| 202（已接受）     | 服务器已接受了请求，但尚未对其进行处理。                     |
| 203（非授权信息） | 服务器已成功处理了请求，但返回了可能来自另一来源的信息。     |
| 204（无内容）     | 服务器成功处理了请求，但未返回任何内容。                     |
| 205（重置内容）   | 服务器成功处理了请求，但未返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如清除表单内容以输入新内容）。 |
| 206（部分内容）   | 服务器成功处理了部分 GET 请求。                              |

300-307表示的意思是：要完成请求，您需要进一步进行操作。通常，这些状态代码是永远重定向的。

| 返回码              | 含义                                                         |
| ------------------- | ------------------------------------------------------------ |
| 300（多种选择）     | 服务器根据请求可执行多种操作。服务器可根据请求者 来选择一项操作，或提供操作列表供其选择。 |
| 301（永久移动）     | 请求的网页已被永久移动到新位置。服务器返回此响应时，会自动将请求者转到新位置。您应使用此代码通知搜索引擎蜘蛛网页或网站已被永久移动到新位置。 |
| 302（临时移动）     | 服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。会自动将请求者转到不同的位置。但由于搜索引擎会继续抓取原有位置并将其编入索引，因此您不应使用此代码来告诉搜索引擎页面或网站已被移动。 |
| 303（查看其他位置） | 当请求者应对不同的位置进行单独的 GET 请求以检索响应时，服务器会返回此代码。对于除 HEAD 请求之外的所有请求，服务器会自动转到其他位置。 |
| 304（未修改）       | 自从上次请求后，请求的网页未被修改过。服务器返回此响应时，不会返回网页内容。 |
| 305（使用代理）     | 请求者只能使用代理访问请求的网页。如果服务器返回此响应，那么，服务器还会指明请求者应当使用的代理。 |
| 307（临时重定向）   | 服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。会自动将请求者转到不同的位置。但由于搜索引擎会继续抓取原有位置并将其编入索引，因此您不应使用此代码来告诉搜索引擎某个页面或网站已被移动。 |

400至417表示的意思是：HTTP状态码表示请求可能出错，会妨碍服务器的处理。

| 返回码                    | 含义                                                         |
| ------------------------- | ------------------------------------------------------------ |
| 400（错误请求）           | 服务器不理解请求的语法。                                     |
| 401（身份验证错误）       | 此页要求授权。您可能不希望将此网页纳入索引。                 |
| 403（禁止）               | 服务器拒绝请求。                                             |
| 404（未找到）             | 服务器找不到请求的网页。例如，对于服务器上不存在的网页经常会返回此代码。 |
| 405（方法禁用）           | 禁用请求中指定的方法。                                       |
| 406（不接受）             | 无法使用请求的内容特性响应请求的网页。                       |
| 407（需要代理授权）       | 此状态码与 401 类似，但指定请求者必须授权使用代理。如果服务器返回此响应，还表示请求者应当使用代理。 |
| 408（请求超时）           | 服务器等候请求时发生超时。                                   |
| 409（冲突）               | 服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，以及两个请求的差异列表。 |
| 410（已删除）             | 请求的资源永久删除后，服务器返回此响应。该代码与 404（未找到）代码相似，但在资源以前存在而现在不存在的情况下，有时会用来替代 404 代码。如果资源已永久删除，您应当使用 301 指定资源的新位置。 |
| 411（需要有效长度）       | 服务器不接受不含有效内容长度标头字段的请求。                 |
| 412（未满足前提条件）     | 服务器未满足请求者在请求中设置的其中一个前提条件。           |
| 413（请求实体过大）       | 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 |
| 414（请求的 URI 过长）    | 请求的 URI（通常为网址）过长，服务器无法处理。               |
| 415（不支持的媒体类型）   | 请求的格式不受请求页面的支持。                               |
| 416（请求范围不符合要求） | 如果页面无法提供请求的范围，则服务器会返回此状态码。         |
| 417（未满足期望值）       | 服务器未满足"期望"请求标头字段的要求。                       |

500至505表示的意思是：服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。

| 返回码                   | 含义                                                         |
| ------------------------ | ------------------------------------------------------------ |
| 500（服务器内部错误）    | 服务器遇到错误，无法完成请求。                               |
| 501（尚未实施）          | 服务器不具备完成请求的功能。例如，当服务器无法识别请求方法时，服务器可能会返回此代码。 |
| 502（错误网关）          | 服务器作为网关或代理，从上游服务器收到了无效的响应。         |
| 503（服务不可用）        | 目前无法使用服务器（由于超载或进行停机维护）。通常，这只是一种暂时的状态。 |
| 504（网关超时）          | 服务器作为网关或代理，未及时从上游服务器接收请求。           |
| 505（HTTP 版本不受支持） | 服务器不支持请求中所使用的 HTTP 协议版本。                   |

------

## 算法/效果

### 前端防抖与节流技术

防抖（`debounce`）：当持续触发事件时，**一定时间段内没有再触发事件，事件处理函数才会执行一次**，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。

节流（`throttle`）：当持续触发事件时，**保证一定时间段内只调用一次事件处理函数**。节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。

**区别**

函数节流不管事件触发有多频繁，都会保证在规定时间内**一定会执行一次**真正的事件处理函数，而函数防抖只是在**最后一次事件后**才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。

**实现**

**防抖**

```js
// 防抖
function debounce(fn, wait) {
    var timeout = null;
    return function() {
        if(timeout !== null)   clearTimeout(timeout);
        timeout = setTimeout(fn, wait);
    }
}
// 处理函数
function handle() {
    console.log(Math.random());
}
```

当持续触发`scroll`事件时，事件处理函数`handle`只在停止滚动1000毫秒之后才会调用一次，也就是说在持续触发`scroll`事件的过程中，事件处理函数`handle`一直没有执行。

**节流**

函数节流主要有两种实现方法：**时间戳**和**定时器**。接下来分别用两种方法实现`throttle`。

节流`throttle`代码（时间戳）：

```js
//节流throttle代码（时间戳）
var throttle = function(func, delay) {
  var prev = Date.now();
  return function() {
    var context = this;
    var args = arguments;
    var now = Date.now();
    if (now - prev >= delay) {
      func.apply(context, args);
      prev = Date.now();
    }
  }
}
//处理函数
function handle() {
　　console.log(Math.random());
}
//滚动事件
window.addEventListener('scroll', throttle(handle, 1000));
```

节流`throttle`代码（定时器），2021年9月8日更新：

```html
// 节流throttle代码（定时器）：
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Document</title>
  <script>
    var myScroll = counter => {
      console.log(`这是第${counter}次节流操作`)
    }
    var throttle = (function(func, delay) { // func：目标函数，delay：节流间隔
      let timer = null, // 定时器
          counter = 0 // 计数器
      return function() {
        if (!timer) { // 如果定时器正在工作，不能打断
          timer = setTimeout(() => { // 启动定时器
            func(counter) // 运行目标方法，即被节流的对象
            counter += 1 // 计数器+1
            timer = null // 一定要将定时器重置为null，否则不会再触发判断
          }, delay);
        }
      }
    })(myScroll, 1000) // 这里需要用到函数立即执行的写法，否则内函数不会执行，只会返回一个方法字符串
                      // 另外，给节流函数的传参要放到立即执行的括号中，否则获取不到参数
  </script>
</head>
<body>
  <div id="window" onscroll="throttle()">
    <div class="main"></div>
  </div>
</body>
<style>
  body {
    display: flex;
    justify-content: center;
    align-items: center;
  }
  #window {
    border: black 1px solid;
    width: 80%;
    height: 600px;
    overflow: auto;
  }
  .main {
    width: 100%;
    height: 8000px;
    background-color: rgba(0, 0, 0, 0.2);
  }
</style>
</html>
```

### js实现滚轮左右滑动效果

在代码编辑器中，常常会有滚轮控制代码左右滚动效果，方便一行代码过长时查看。因此，想实现一个滚轮控制页面元素左右移动的效果。

实现的重点有：

1. 获取鼠标滚轮事件：mousewheel。
2. 判断滚轮是**向上滚动**还是**向下滚动**：回调参数中的**deltaY**来判断。
3. 滚动的元素要设置**postion: relative**。

首先写一个简单的`html`：

```html
<div class="show_window" @mousewheel="mouseScroll">
    <div id="scrollBox" class="actual_content">
        {{say}}
    </div>
</div>
```

内层的`scrollBox`是需要滚动的部分，外层盒子是可视区域。

下面是简单的`css`：

```css
body {
  display: flex;
  justify-content: center;
}
.show_window {
   width: 400px;
   height: 300px;
   border: 1px solid #000000;
   overflow: hidden;
}
.actual_content {
   width: 1200px;
   height: 200px;
   position: relative;
   background-color: aqua;
}
```

最后是`js`部分，在滚轮事件的回调参数中，通过`deltaY`属性的正负来判断滚动方向（上为100，负为-100）；通过改变滚动盒子的`left`属性来控制位置移动。

```js
mouseScroll(e) {
  let left = parseFloat(document.querySelector('#scrollBox').style.left),
  pace = 30 // 滚动一次的距离，这里设置的单位是px
  if (!left) {
    e.deltaY > 0 ? 
    document.querySelector('#scrollBox').style.left = `${pace}px`
    :
    document.querySelector('#scrollBox').style.left = `-${pace}px`
  } else {
    e.deltaY > 0 ? 
    document.querySelector('#scrollBox').style.left = left + pace + 'px'
    :
    document.querySelector('#scrollBox').style.left = left - pace + 'px'
  }
}

```

### 闰年判断逻辑

**闰年能被4整除且不能被100整除，或能被400整除。**

```js
year % 4 == 0 && year % 100 != 0 || year % 400 == 0
```

### 获取数组的所有子集

给定一个数组，求它的所有子集（零元素到满数组），元素可重复。

| 元素个数 | 所有子集的数量 |
| :------: | :------------: |
|    0     |       1        |
|    1     |       2        |
|    2     |       4        |
|    3     |       8        |
|    4     |       16       |

可见元素个数为`n`时，数组有`2的n次方`个子集，也就是`2的n次方`种情况，这些情况中，每个元素都只有**出现**或者不出现两种状态。因此，可以**用二进制来代替元素出现的情况**，例如：

定义数组`[1, 2, 3]`，则它的所有子集以及和二进制数的关系为

| 子集编号 | 对应二进制数 |  子集数组   |
| :------: | :----------: | :---------: |
|   `0`    |    `000`     |    `[]`     |
|   `1`    |    `001`     |    `[3]`    |
|   `2`    |    `010`     |    `[2]`    |
|   `3`    |    `011`     |  `[2, 3]`   |
|   `4`    |    `100`     |    `[1]`    |
|   `5`    |    `101`     |  `[1, 3]`   |
|   `6`    |    `110`     |  `[1, 2]`   |
|   `7`    |    `111`     | `[1, 2, 3]` |

二进制数中，`0`代表该位置上的元素不出现，`1`代表出现。

### 动态规划-01背包问题

思想：将情况复杂度由小到大递归，逐步更新最优解。

1. 当只有一件物品时，容量由小到大，依次判断最优解；
2. 将第`i`件物品加入，容量由小到大，每次都进行一次判断：
   1. 当前容量下能否单独装下第`i`件物品？若不能，维持该容量下的最优解；若能，进入下一步判断；
   2. 当前容量单独装第`i`件物品时，剩余多少容量？若不剩余容量，则判断当前解与最优解的值并更新；若容量还有剩余`j`，进入下一步判断；
   3. 去往剩余容量`j`的所在列，找出该列（不包含第`i`件物品）的最优解，与第`i`件物品的价值相加后，与当前最优解判断并更新；
3. 以此类推，直到最后一个物品加入的情况更新完。

| 物品\容量           | 1             | 2                                                            | 3                                                            | 4                                                            |
| ------------------- | ------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 电脑     2000     3 | 0             | 0                                                            | 2000     电脑                                                | 2000     电脑                                                |
| 吉他     1500     1 | 1500     吉他 | 1500     吉他                                                | 当前容量3的最优解为电脑；     但多出一个可选项：吉他；     若选了吉他，价值1500，剩余2容量；     观察目前有值的、除了吉他行的、容量为2的其他行，最高价值为0；     所以如果选吉他，最终价值为1500+0=1500，小于目前最优解2000；     保持最优解：     2000     电脑 | 当前容量4的最优解为电脑；     但多出一个可选项：吉他；     若选了吉他，价值1500，剩余3容量；     观察目前有值的、除了吉他行的、容量为3的其他行，最高价值为2000；     所以如果选吉他，最终价值为1500+2000=3500，大于目前最优解2000；     更新最优解：     3500     电脑+吉他 |
| 音响     3000     4 | 1500     吉他 | 1500     吉他                                                | 2000     电脑                                                | 3500     电脑+吉他                                           |
| 手机     2000     1 | 2000     手机 | 这里的逻辑应该是：     目前容量2的最优解是吉他，价值1500；     但多出一个可选项：手机；     并不能因为最优解吉他剩余容量为1，而手机恰好占容量也为1就直接将手机加入；     依旧走流程：若选了手机，价值2000，剩余容量1；     查找除了手机行的、容量为1的最优解，为吉他，吉他1500+手机2000大于当前最优解；     更新最优解：     3500     手机+吉他 | 3500     手机+吉他                                           | 4000     手机+电脑                                           |

------

## 样式

### css

#### 圆角梯形

简单记录一下圆角梯形的简陋版本。

主要使用了`clip-path`和`border-radius`属性，直接上代码：

```css
.module-title {
  // border: #111 1px solid;
  width: 124px;
  padding: 10px 20px 10px 0;
  text-align: center;
  color: white;
  background-color: rgba(40, 82, 255, 1);
  clip-path: polygon(0px 0px, 103.74875px 0px, 124.001px 100%, 0px 100%);
  border-radius: 10px 41.99875px 0 0;
  border: rgba(89, 221, 250, .8) 1px solid;
  border-bottom: none;
}
```

其中`clip-path: polygon()`表示绘制多边形，参数为任意个点的坐标（左上角为原点），将点连接起来就是绘制后的图形，再加上圆角属性，勉强可以达到效果，但右上圆角变化得显得稍微突兀。

其实最完美的方法是**不使用`border-radius`属性，而是只通过`clip-path: polygon()`绘制出完整图形**，但为了绘制出圆角，那样的坐标参数会变得非常多。

#### 表格内容过多导致挤压其余部分问题解决

`table`表格`td`设置宽度后文字太多会导致自动换行，可以参考以下方案：

设置`table`的`style="table-layout:fixed;"` 然后设置`td`的`style="word-wrap:break-word;"` 即可。

#### 表格

原生html，将一大串元素对齐排列，就像表格一样。

```html
<!-- 首先需要有table标签 -->
<table>
    <!-- tr代表行 -->
    <tr>
    	<!-- 行中有单元格，指表格数据（table data）-->
        <td>row 1, cell 1</td>
		<td>row 1, cell 2</td>
    </tr>
    <tr>
		<td>row 2, cell 1</td>
		<td>row 2, cell 2</td>
	</tr>
</table>
```

#### animation实现动画（闪烁）效果

[官网](https://www.w3school.com.cn/cssref/pr_animation.asp)

`animation`实现元素的动画效果，可循环

例：实现元素闪动效果

首先定义关键帧`@keyframes`，在一次动画效果中，可以细分每一时刻的样式内容，用`数字+%`的形式定义，其中`from`等价于`0%`，`to`等价于`100%`。**要注意添加对应浏览器的前缀名。**

```css
@keyframes testBox {
    0% {
    	opacity: 1;
    }
    50% {
        opacity: 0;
    }
    100% {
        opacity: 1;
    }
}
@-webkit-keyframes testBox {
    0% {
    	opacity: 1;
    }
    50% {
        opacity: 0;
    }
    100% {
        opacity: 1;
    }
}
/* 将动画内容挂载到元素上，通过定义的名称 */
div {
    background-color: orangered;
      width: 100px;
      height: 100px;
      animation: testBox 1s linear infinite alternate;
      -webkit-animation: testBox 1s linear infinite alternate;
}
```

`animation`属性分别代表：*动画名称*、*一次动画的时长*、*变化效果函数*、*重复次数*和*效果结束后是否往返*。

#### class和id的区别

`class`可复用，多个元素可以使用相同的`class`名，相当于先定义`class`的样式，再赋值到不同的元素上。

`id`是唯一的，`id`只能最多被一个元素使用，相当于先指定元素，再定义样式。

`id`的优先级**高于**`class`

页面中对元素进行脚本操作，如果只是对某个特定元素操作，使用`id`效率高，如果对批量元素进行操作，可以使用`class`或`tagName`

#### 长度单位

| 单位 | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| em   | 相对于元素的字体大小（font-size）（2em 表示当前字体大小的 2 倍） |
| ex   | 相对于当前字体的 x-height(极少使用)                          |
| ch   | 相对于 "0"（零）的宽度                                       |
| rem  | 相对于根元素的字体大小（font-size）                          |
| vw   | 相对于视口*宽度的 1%                                         |
| vh   | 相对于视口*高度的 1%                                         |
| vmin | 相对于视口*较小尺寸的 1％                                    |
| vmax | 相对于视口*较大尺寸的 1％                                    |
| %    | 相对于父元素                                                 |

#### transform

转换元素，改变位置、角度等

```css
transform: none|transform-functions;
```

| 值                                                           | 描述                                    |
| :----------------------------------------------------------- | :-------------------------------------- |
| none                                                         | 定义不进行转换。                        |
| matrix(*n*,*n*,*n*,*n*,*n*,*n*)                              | 定义 2D 转换，使用六个值的矩阵。        |
| matrix3d(*n*,*n*,*n*,*n*,*n*,*n*,*n*,*n*,*n*,*n*,*n*,*n*,*n*,*n*,*n*,*n*) | 定义 3D 转换，使用 16 个值的 4x4 矩阵。 |
| translate(*x*,*y*)                                           | 定义 2D 转换。                          |
| translate3d(*x*,*y*,*z*)                                     | 定义 3D 转换。                          |
| translateX(*x*)                                              | 定义转换，只是用 X 轴的值。             |
| translateY(*y*)                                              | 定义转换，只是用 Y 轴的值。             |
| translateZ(*z*)                                              | 定义 3D 转换，只是用 Z 轴的值。         |
| scale(*x*,*y*)                                               | 定义 2D 缩放转换。                      |
| scale3d(*x*,*y*,*z*)                                         | 定义 3D 缩放转换。                      |
| scaleX(*x*)                                                  | 通过设置 X 轴的值来定义缩放转换。       |
| scaleY(*y*)                                                  | 通过设置 Y 轴的值来定义缩放转换。       |
| scaleZ(*z*)                                                  | 通过设置 Z 轴的值来定义 3D 缩放转换。   |
| rotate(*angle*)                                              | 定义 2D 旋转，在参数中规定角度。        |
| rotate3d(*x*,*y*,*z*,*angle*)                                | 定义 3D 旋转。                          |
| rotateX(*angle*)                                             | 定义沿着 X 轴的 3D 旋转。               |
| rotateY(*angle*)                                             | 定义沿着 Y 轴的 3D 旋转。               |
| rotateZ(*angle*)                                             | 定义沿着 Z 轴的 3D 旋转。               |
| skew(*x-angle*,*y-angle*)                                    | 定义沿着 X 和 Y 轴的 2D 倾斜转换。      |
| skewX(*angle*)                                               | 定义沿着 X 轴的 2D 倾斜转换。           |
| skewY(*angle*)                                               | 定义沿着 Y 轴的 2D 倾斜转换。           |
| perspective(*n*)                                             | 为 3D 转换元素定义透视视图。            |

演示示例：https://c.runoob.com/codedemo/3391

#### transition

控制元素的过渡效果

```css
.div {
    width: 100px;
    height: 200px;
	transition: width 1s ease .1s, height 1s ease-in .1s;
}
.div:hover {
    width: 100%;
    height: 800px;
}
```

`transition`有四个参数，分别是

- `transition-property`：指定`CSS`属性的`name`，`transition`效果
- `transition-duration`：`transition`效果需要指定多少秒或毫秒才能完成
- `transition-timing-function`：指定transition效果的转速曲线
- `transition-delay`：定义transition效果开始的时候

其中，转速曲线值有：

| 值                            | 描述                                                         |
| :---------------------------- | :----------------------------------------------------------- |
| linear                        | 规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。 |
| ease                          | 规定慢速开始，然后变快，然后慢速结束的过渡效果（cubic-bezier(0.25,0.1,0.25,1)）。 |
| ease-in                       | 规定以慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)）。  |
| ease-out                      | 规定以慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)）。  |
| ease-in-out                   | 规定以慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)）。 |
| cubic-bezier(*n*,*n*,*n*,*n*) | 在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值。 |

#### 居中

首先清除默认样式

```css
html, body {
	width: 100%;
	height: 100%;
	margin: 0;
	padding: 0;
}
```

1. ```css
   .content {
   	width: 300px;
   	height: 300px;
   	margin: 0 auto; /*水平居中*/
   	position: relative;
   	top: 50%;
   	transform: translateY(-50%);
   }
   ```


#### cursor

| 值        | 描述                                                         |
| :-------- | :----------------------------------------------------------- |
| *url*     | 需使用的自定义光标的 URL。注释：请在此列表的末端始终定义一种普通的光标，以防没有由 URL 定义的可用光标。 |
| default   | 默认光标（通常是一个箭头）                                   |
| auto      | 默认。浏览器设置的光标。                                     |
| crosshair | 光标呈现为十字线。                                           |
| pointer   | 光标呈现为指示链接的指针（一只手）。                         |
| grab      | 光标呈现为一只可抓握的手（IE不可用）。                       |
| grabing   | 光标呈现为一只正在抓握的手（IE不可用）。                     |
| zoom-in   | 放大镜（IE不可用）。                                         |
| zoom-out  | 缩小镜（IE不可用）。                                         |
| move      | 此光标指示某对象可被移动。                                   |
| e-resize  | 此光标指示矩形框的边缘可被向右（东）移动。                   |
| ne-resize | 此光标指示矩形框的边缘可被向上及向右移动（北/东）。          |
| nw-resize | 此光标指示矩形框的边缘可被向上及向左移动（北/西）。          |
| n-resize  | 此光标指示矩形框的边缘可被向上（北）移动。                   |
| se-resize | 此光标指示矩形框的边缘可被向下及向右移动（南/东）。          |
| sw-resize | 此光标指示矩形框的边缘可被向下及向左移动（南/西）。          |
| s-resize  | 此光标指示矩形框的边缘可被向下移动（南）。                   |
| w-resize  | 此光标指示矩形框的边缘可被向左移动（西）。                   |
| text      | 此光标指示文本。                                             |
| wait      | 此光标指示程序正忙（通常是一只表或沙漏）。                   |
| help      | 此光标指示可用的帮助（通常是一个问号或一个气球）。           |

#### 样式名之间空格，无空格和大于号的区别

**两者之间无空格：多类选择器**

通过把多个类选择器链接在一起，**仅可以**选择**同时包含这些类名的元素（类名的顺序不限）**

```css
.layout.float { color: red; }
```

```html
<div class="layout float">被选择的元素</div>
```

**两者之间有空格：后代选择器**

`.layout` `.float`  中间用**空格隔开**，表示后代选择器，选择的是`.layout`**内的**`.float` (两个元素之间的层次间隔可以是无限的)

```css
.layout .float{
  color: orange;
}
```

```html
<div class="layout">
    <div class="float">被选择的元素</div>
</div>
```

**两者之间是大于号：子元素选择器**

```css
.layout > .float{
  color: blue;
}
```

```html
<div class="layout">
    <div class="float">被选择的元素</div>
    <div>
        <div class="float">没有被选择的元素</div>
    </div>
</div>
```

所以 `.layout.float .left{}` 的意思是类名包含“`layout float`”的元素，其后代类名包含“`left`”的元素被选中。

#### :class

https://cn.vuejs.org/v2/guide/class-and-style.html#%E7%BB%91%E5%AE%9A-HTML-Class

[对象语法](https://cn.vuejs.org/v2/guide/class-and-style.html#对象语法)

我们可以传给 `v-bind:class` 一个对象，以动态地切换 class：

```
<div v-bind:class="{ active: isActive }"></div>
```

上面的语法表示 `active` 这个 class 存在与否将取决于数据 property `isActive` 的 [truthiness](https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy)。

你可以在对象中传入更多字段来动态切换多个 class。此外，`v-bind:class` 指令也可以与普通的 class attribute 共存。当有如下模板：

```vue
<div
  class="static"
  v-bind:class="{ active: isActive, 'text-danger': hasError }"
></div>
```

和如下 data：

```js
data: {
  isActive: true,
  hasError: false
}
```

结果渲染为：

```vue
<div class="static active"></div>
```

当 `isActive` 或者 `hasError` 变化时，class 列表将相应地更新。例如，如果 `hasError` 的值为 `true`，class 列表将变为 `"static active text-danger"`。

绑定的数据对象不必内联定义在模板里：

```vue
<div v-bind:class="classObject"></div>
data: {
  classObject: {
    active: true,
    'text-danger': false
  }
}
```

渲染的结果和上面一样。我们也可以在这里绑定一个返回对象的[计算属性](https://cn.vuejs.org/v2/guide/computed.html)。这是一个常用且强大的模式：

```vue
<div v-bind:class="classObject"></div>
data: {
  isActive: true,
  error: null
},
computed: {
  classObject: function () {
    return {
      active: this.isActive && !this.error,
      'text-danger': this.error && this.error.type === 'fatal'
    }
  }
}
```

#### flex

[教程](https://www.cnblogs.com/hellocd/p/10443237.html)

`display: flex` 意为弹性布局，行内元素也可以使用`flex`：`display: inline-flex`。

使用了flex布局的元素成为flex容器，容器的内部布局如下：

![](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png)

- 水平主轴（main axis），从左到右
- 垂直交叉轴（cross axis），从上到下

**容器属性：**

- `flex-direction`：项目的排列方向

  ```css
  .box {
    flex-direction: row | row-reverse | column | column-reverse;
  }
  ```

  ![](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071005.png)

- `flex-wrap`：定义换行方式

  ```css
  .box{
    flex-wrap: nowrap | wrap | wrap-reverse;
  }
  ```

  `nowrap`（默认）：不换行

  ![](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071007.png)

  `wrap`：换行，上到下排列

  ![](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071008.jpg)

  `wrap-reverse`：换行，下到上排列

  ![](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071009.jpg)

- `flex-flow`：`flex-flow`属性是`flex-direction`属性和`flex-wrap`属性的简写形式，默认值为`row nowrap`。

  ```css
  .box {
    flex-flow: <flex-direction> || <flex-wrap>;
  }
  ```

- `justify-content`：定义项目在主轴上的对齐方式。

  ```css
  .box {
    justify-content: flex-start | flex-end | center | space-between | space-around;
  }
  ```

  <img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png"  />

  - `flex-start`（默认值）：左对齐
  - `flex-end`：右对齐
  - `center`： 居中
  - `space-between`：两端对齐，项目之间的间隔都相等。
  - `space-around`：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。

- `align-items`：定义项目在交叉轴上如何对齐。

  ```css
  .box {
    align-items: flex-start | flex-end | center | baseline | stretch;
  }
  ```

  ![](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png)

  - `flex-start`：交叉轴的起点对齐。
  - `flex-end`：交叉轴的终点对齐。
  - `center`：交叉轴的中点对齐。
  - `baseline`: 项目的第一行文字的基线对齐。
  - `stretch`（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。

- `align-content`：定义多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。

  ```css
  .box {
    align-content: flex-start | flex-end | center | space-between | space-around | stretch;
  }
  ```

  ![](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png)

  - `flex-start`：与交叉轴的起点对齐。
  - `flex-end`：与交叉轴的终点对齐。
  - `center`：与交叉轴的中点对齐。
  - `space-between`：与交叉轴两端对齐，轴线之间的间隔平均分布。
  - `space-around`：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。
  - `stretch`（默认值）：轴线占满整个交叉轴。

**项目属性：**

- `order`：定义项目的排列顺序。数值越小，排列越靠前，默认为0。

  ```css
  .item {
    order: <integer>;
  }
  ```

  ![](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071013.png)

- `flex-grow`：定义项目的放大比例，默认为`0`，即如果存在剩余空间，也不放大。

  ```css
  .item {
    flex-grow: <number>; /* default 0 */
  }
  ```

  ![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071014.png)

  如果所有项目的`flex-grow`属性都为`1`，则它们将等分剩余空间（如果有的话）。如果一个项目的`flex-grow`属性为`2`，其他项目都为`1`，则前者占据的剩余空间将比其他项多一倍。

- `flex-shrink`：定义项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。

  ```css
  .item {
    flex-shrink: <number>; /* default 1 */
  }
  ```

  ![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071015.jpg)

  如果所有项目的`flex-shrink`属性都为1，当空间不足时，都将等比例缩小。如果一个项目的`flex-shrink`属性为0，其他项目都为1，则空间不足时，前者不缩小。

  负值对该属性无效。

- `flex-basis`:定义在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为`auto`，即项目的本来大小。

  ```css
  .item {
    flex-basis: <length> | auto; /* default auto */
  }
  ```

  它可以设为跟`width`或`height`属性一样的值（比如`350px`），则项目将占据固定空间。

- `flex`：`flex-grow`, `flex-shrink` 和 `flex-basis`的简写，默认值为`0 1 auto`。后两个属性可选。

  ```css
  .item {
    flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]
  }
  ```

  该属性有两个快捷值：`auto` (`1 1 auto`) 和 none (`0 0 auto`)。

  建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。

- `align-self`：允许单个项目有与其他项目不一样的对齐方式，可覆盖`align-items`属性。默认值为`auto`，表示继承父元素的`align-items`属性，如果没有父元素，则等同于`stretch`。

  ```css
  .item {
    align-self: auto | flex-start | flex-end | center | baseline | stretch;
  }
  ```

  ![](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071016.png)

  该属性可能取6个值，除了auto，其他都与align-items属性完全一致。

#### position

https://www.w3school.com.cn/cssref/pr_class_position.asp

| 值       | 描述                                                         |
| :------- | :----------------------------------------------------------- |
| absolute | 生成绝对定位的元素，相对于 static 定位以外的**第一个父元素**进行定位。元素的位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定。<br />**注意！**若position为absolute时元素相对于body进行了定位，那是因为：绝对定位元素相对的元素是它**最近的一个祖先，该祖先满足：position的值必须是：relative、absolute、fixed，若没有这样的祖先则相对于body进行定位**。偏移值由其`top`、`bottom`、`left`、`right`值确定。而绝对定位的元素若超出其父元素的边界，要想将溢出的部分隐藏，则，想隐藏在哪个祖先里，该祖先必须同时设置`position:relative/absolute/fixed`和`overflow:hidden`的值。 |
| fixed    | 生成绝对定位的元素，相对于**浏览器窗口**进行定位。元素的位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定。 |
| relative | 生成相对定位的元素，相对于其**正常位置**进行定位。因此，"left:20" 会向元素的 LEFT 位置添加 20 像素。 |
| static   | 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。 |
| inherit  | 规定应该从父元素继承 position 属性的值。                     |

#### text-align

想要元素居中，要用<div>包裹住元素，并在父元素设置`text-align: center;`

#### em

`em`是一个**相对**的单位，是当前元素相对于**父元素字体**的大小而言；例如：父元素设置`font-size: 32px` ，子元素设置`font-size: 1em` ，那么子元素的字体大小也是`32px`；如果父元素没有设置字体大小的话，就是想对于浏览器**默认的字体大小**而言

#### >>>

深度选择器，可用于单个页面的Element UI组件样式的修改。

#### ！important

无论出现的顺序，属性后加`!important`的优先级最高。

------

### scss

#### 嵌套样式

在父级样式中添加子级样式时，使用`&`符号标识。

```scss
::v-deep.el-tag--dark{
  border-radius: 20px;
  margin: 0;
  padding: 0;
  &.circle{ /*圆形标签样式*/
    width: 24px;
    height: 24px;
  }
  &.round{ /*圆角标签样式*/
    text-align: center;
    width: 70px;
    height: 28px;
    color: #FFFFFF;
  }
}
```

**Sass 允许将一套 CSS 样式嵌套进另一套样式中，内层的样式将它外层的选择器作为父选择器**

```scss
#app {  
  h1 {
    text-align: center;
  }
}
```

编译结果

```scss
#app h1 { text-align: center; }
```

避免了重复输入父选择器，而且令复杂的 CSS 结构更易于管理。

**父选择器 `&`**

在上一个例子中如果父子嵌套，但是我想操作 `#app` 的`:hover` 此时可以用 `&` 代表嵌套规则外层的父选择器。

```scss
a {
  font-weight: bold;
  text-decoration: none;
  &:hover { text-decoration: underline; }
  body.firefox & { font-weight: normal; }
}
```

编译为

```scss
a {
  font-weight: bold;
  text-decoration: none; 
}
a:hover {
  text-decoration: underline;
}
body.firefox a {
  font-weight: normal; 
}
```

 编译后的 CSS 文件中 `&` 将被替换成**嵌套外层的父选择器**，如果含有多层嵌套，最外层的父选择器会一层一层向下传递

`&`所在的位置只代表了他的父亲，也就是说在每一层，指向是都是**他所在的父元素**。

```scss
#main {
  color: black;
  a {
    font-weight: bold;
    &:hover { color: red; }
  }
}
```

编译为

```scss
#main {
  color: black; 
}
#main a {
   font-weight: bold; 
}
#main a:hover {
  color: red; 
}
```

**属性嵌套**

有些 CSS 属性遵循相同的命名空间 (namespace)，比如 `font-family, font-size, font-weight` 都以 `font` 作为属性的命名空间。为了便于管理这样的属性，同时也为了避免了重复输入，Sass 允许将属性嵌套在命名空间中，例如：

```scss
.funky {
  font: {
    family: fantasy;
    size: 30em;
    weight: bold;
  }
}
```

编译为

```scss
.funky {
  font-family: fantasy;
  font-size: 30em;
  font-weight: bold; 
}
```

命名空间也可以包含自己的属性值，例如：

```scss
.funky {
  font: 20px/24px {
    family: fantasy;
    weight: bold;
  }
}
```

编译为

```scss
.funky {
  font: 20px/24px;
  font-family: fantasy;
  font-weight: bold; 
}
```

#### ::v-deep

深度选择器，选择器后面要加空格。

#### @mixin与@include

`@mixin`指令允许我们定义一个可以在整个样式表中重复使用的样式。

`@includ` 指令可以将混入（`mixin`）引入到文档中。

**定义一个混入：**

```less
@mixin important-text {
  color: red;
  font-size: 25px;
  font-weight: bold;
  border: 1px solid blue;
}
//注意：Sass 的连接符号 - 与下划线符号 _ 是相同的，也就是 @mixin important-text { } 与 @mixin important_text { } 是一样的混入。
```

**使用混入：**

```less
selector {
  @include mixin-name;
}
```

**转换为`css`代码：**

```CSS
.danger {
  color: red;
  font-size: 25px;
  font-weight: bold;
  border: 1px solid blue;
  background-color: green;
}
```

混入中也可以包含混入，如下所示：

```less
@mixin special-text {
  @include important-text;
  @include link;
  @include special-border;
}
```

向混入传递变量

```less
/* 混入接收两个参数 */
@mixin bordered($color, $width) {
  border: $width solid $color;
}

.myArticle {
  @include bordered(blue, 1px);  // 调用混入，并传递两个参数
}

.myNotes {
  @include bordered(red, 2px); // 调用混入，并传递两个参数
}

/*设定默认值*/
@mixin bordered($color: blue, $width: 1px) {
  border: $width solid $color;
}
```

**可变参数**

有时，不能确定一个混入（`mixin`）或者一个函数（`function`）使用多少个参数，这时我们就可以使用 **...** 来设置可变参数。

例如，用于创建盒子阴影（`box-shadow`）的一个混入（`mixin`）可以采取任何数量的 `box-shadow` 作为参数。

```less
@mixin box-shadow($shadows...) {
      -moz-box-shadow: $shadows;
      -webkit-box-shadow: $shadows;
      box-shadow: $shadows;
}

.shadows {
  @include box-shadow(0px 4px 5px #666, 2px 6px 10px #999);
}
```

将以上代码转换为 `CSS` 代码，如下所示：

```css
.shadows {
  -moz-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;
  -webkit-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;
  box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;
}
```



------

## Vue/Js

### 概念

#### 网页内容、结构与表现相分离的含义

**什么是页面内容**

页面内容指网页所包含和传达的信息，比如文字、视频、音频等。

**什么是结构**

仅仅展示内容会让页面显得拥挤和杂乱无章，需要合理的结构将不同类别的内容区分开，便于获取信息，比如标题、正文、底部信息等。

**什么是表现**

表现相当于美化外观，在合理结构的基础上，给予网页背景、文字样式等修饰。

分离即是以上三个概念相互独立，可以使用同一种结构展示不同的内容，也可以用不同的表现形式展现相同的内容。

#### 瀑布流布局

**瀑布流布局的原理**
瀑布流布局要求要进行布置的元素等宽，然后计算元素的宽度与浏览器宽度之比，得到需要布置的列数。
创建一个数组，长度为列数，里面的值为已布置元素的总高度（最开始为0）
然后将未布置的元素依次布置到高度最小的那一列，就得到了瀑布流布局。

```html
<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>demo water-basic</title>
	<style type="text/css">
		.water-basic {
			position: relative;
		}
		.item {
			position: absolute;
			width: 200px;
			margin: 5px;
			transition: all 1s;
		}
		.box1 {
			height: 500px;
			background-color: red;
		}
		.box2 {
			height: 300px;
			background-color: blue;
		}
		.box3 {
			height: 200px;
			background-color: gray;
		}
		.box4 {
			height: 700px;
			background-color: pink;
		}
		.box5 {
			height: 600px;
			background-color: yellow;
		}
	</style>
	<script src="http://apps.bdimg.com/libs/jquery/1.9.1/jquery.min.js"></script>
</head>
<body>
<div class="water-basic">
	<div class="item box1">1</div>
	<div class="item box2">2</div>
	<div class="item box1">3</div>
	<div class="item box4">4</div>
	<div class="item box5">5</div>
	<div class="item box3">6</div>
	<div class="item box2">7</div>
	<div class="item box1">8</div>
	<div class="item box1">9</div>
	<div class="item box2">10</div>
	<div class="item box4">11</div>
	<div class="item box3">12</div>
	<div class="item box1">13</div>
	<div class="item box5">14</div>
	<div class="item box2">15</div>
	<div class="item box1">16</div>
	<div class="item box3">17</div>
	<div class="item box1">18</div>
	<div class="item box2">19</div>
	<div class="item box1">20</div>
	<div class="item box4">21</div>
	<div class="item box5">22</div>
	<div class="item box3">23</div>
	<div class="item box2">24</div>
	<div class="item box1">25</div>
	<div class="item box1">26</div>
	<div class="item box2">27</div>
	<div class="item box4">28</div>
	<div class="item box3">29</div>
	<div class="item box1">30</div>
	<div class="item box5">31</div>
	<div class="item box2">32</div>
	<div class="item box1">33</div>
	<div class="item box3">34</div>
</div>


<script type="text/javascript">
	var waterBasic = (function(){
		function init(){
			var nodeWidth = $(".item").outerWidth(true),
				colNum = parseInt( $(window).width() / nodeWidth ),
				colSumHeight = [];

			for (var i=0;i<colNum;i++) {
				colSumHeight.push(0);
			}

			$(".item").each(function(){
				var $cur = $(this),
					idx = 0,
					minSumHeight = colSumHeight[0];

				// 获取到solSumHeight中的最小高度
				for (var i=0;i<colSumHeight.length;i++) {
					if (minSumHeight > colSumHeight[i]) {
						minSumHeight = colSumHeight[i];
						idx = i;
					}
				}

				// 设置各个item的css属性
				$cur.css({
					left: nodeWidth*idx,
					top: minSumHeight
				})

				// 更新solSumHeight
				colSumHeight[idx] = colSumHeight[idx] + $cur.outerHeight(true);
			})
		}


		// 设置窗口改变时也能重新加载
		$(window).on("resize", function(){
			init();
		})


		return {
			init: init
		}
	})();

	waterBasic.init();
</script>
</body>
</html>
```

#### 原型链

原型链就是原型之间的继承关系。

首先明确一下构造函数、实例和原型对象之间的关系。

创建一个`SuperType`类型，**构造函数**为：

```js
function SuperType() {
	this.property = true
}
```

通过构造函数，创建出一个**实例对象superOne**，`superOne`拥有构造函数赋予的属性`property`：

```js
let superOne = new SuperType()	
superOne.property // true

// 定义原型方法，实例出来的所有对象都可以使用这个方法
SuperType.prototype.getSuperValue = function() {
    return this.property
}
superOne.getSuperValue() // true
```

```js
 SuperType 
（构造函数）
    |                          
    |                      		        
    |                 		          
    |  new           		        
    |              			  
    V              		        
  superOne
 （实例）
```

其中，`superOne`对象中有一个内部指针**\__proto__**指向`superOne`的原型，也即构造函数`SuperType`的原型对象**prototype**：

```js
superOne.__proto__ === SuperType.prototype // true
SuperType.prototype = { // 原型对象
    constructor: f SuperType(), // 指向构造函数，即SuperType本身
    __proto__: Object // 原型对象的原型
}
```

```js
				prototype
SuperType   ----------------------> SuperType.prototype
（构造函数）                             （原型对象）
    |                                     ^
    |                      		        /
    |                 		          /
    |  new           		        /
    |              			      /
    V              		         /
  superOne  --------------------/
 （实例）        __proto__
```

原型对象中，`constructor`属性指向构造函数本身，所以

```js
SuperType.prototype.constructor === SuperType // true
```

因此，构造函数、实例和原型对象之间的关系表示为：

```js
				prototype
SuperType   ----------------------> SuperType.prototype
（构造函数） <----------------------     （原型对象）
    |            constructor              ^
    |                      		        /
    |                 		          /
    |  new           		        /
    |              			      /
    V              		         /
  superOne  --------------------/
 （实例）        __proto__
```

当**原型对象是另一个类型的实例**时(`anotherOne.prototype = new SuperType()`)，两个关系之间就形成了原型链，`anotherOne`实现了对`SuperType`的继承。

```js
function SubType() {
    this.subProperty = false
}

// 定义原型方法
SubType.prototype.getSubValue = function() {
    return this.subProperty
}

// 继承SuperType
SubType.prototype = new SuperType()
```

此时`SubType`实例继承了`SuperType`的方法：

```js
let subOne = new SubType()
subOne.getSuperValue() // true
subOne.getSubValue() // false
```

这里可以注意到，在实例中查找属性时，若实例中没有，则去实例的原型中查找，如果还没有，就查找原型的原型，以此类推，直到顶层。

**subOne.getSuperValue()**时，先查找了`subOne`，然后是`SubType.prototype`，最后才是`SuperType.prototype`，至此经历了三层查找。同理，

```js
superOne.constructor === SuperType // 实例中没有constructor属性，因此在实例的原型中查找，即superOne.__proto__.constructor
```

因为`SubType`继承了`SuperType`，所以`subOne.constructor`变为`SuperOne.constructor`，即`Supertype`。

#### Map对象

**`Map`** 对象保存键值对，并且能够记住键的原始插入顺序。任何值(对象或者[原始值](https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive)) 都可以作为一个键或一个值。

一个Map对象在迭代时会根据对象中元素的插入顺序来进行一个  [`for...of`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of)为[key，value]的数组。

**属性**

`Map.length`

`length`的值为0，想要计算一个`Map`中的条目数量，使用`Map.prototype.size`。

**方法**

[`Map.prototype.clear()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/clear)

移除Map对象的所有键/值对 。

[`Map.prototype.delete(key)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/delete)

如果 `Map` 对象中存在该元素，则移除它并返回 *`true`*；否则如果该元素不存在则返回 `*false*`。随后调用 `Map.prototype.has(key)` 将返回 `false` 。

[`Map.prototype.entries()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/entries)

返回一个新的 `Iterator` 对象，它按插入顺序包含了Map对象中每个元素的 **`[key, value]`** **`数组`**。

[`Map.prototype.forEach(callbackFn[, thisArg\])`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/forEach)

按插入顺序，为 `Map`对象里的每一键值对调用一次callbackFn函数。如果为forEach提供了thisArg，它将在每次回调中作为this值。

[`Map.prototype.get(key)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/get)

返回键对应的值，如果不存在，则返回undefined。

[`Map.prototype.has(key)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/has)

返回一个布尔值，表示Map实例是否包含键对应的值。

[`Map.prototype.keys()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/keys)

返回一个新的 `Iterator`对象， 它按插入顺序包含了Map对象中每个元素的**键** 。

[`Map.prototype.set(key, value)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/set)

设置Map对象中键的值。返回该Map对象。

[`Map.prototype.values()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/values)

返回一个新的`Iterator`对象，它按插入顺序包含了Map对象中每个元素的**值** 。

[`Map.prototype[@@iterator]()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/@@iterator)

返回一个新的`Iterator`对象，它按插入顺序包含了Map对象中每个元素的 **`[key, value]`** **`数组`**。

#### qs

**qs 是一个增加了一些安全性的查询字符串解析和序列化字符串的库。**

**安装**

```shell
npm install qs	
```

**引入**

```js
import qs from 'qs'
```

`qs.parse()`：将URL解析成对象的形式

`qs.stringify()`：将对象序列化成URL的形式，以`&`进行拼接

```js
let data = qs.stringify({
    "username":this.username,
    "password":this.password
});
// username=renping&password=123456
```

#### npm run dev

`npm run dev`或 `npm run serve`实际上是执行配置在`package.json`的脚本，例如：

```json
"scripts": {
　　"serve": "vue-cli-service serve",
　　"build": "vue-cli-service build",
　　"lint": "vue-cli-service lint"
},
```

`npm run xxx` 中的 `xxx` 可以理解为键值对的 `key`，实际上 `run` 的是在 `package.json` 里面 `scripts` 配置的 `value`；

比如，`npm run serve` 实际运行的是 `vue-cli-service serve`。

#### 路由懒加载和组件懒加载

**路由懒加载（vue异步组件实现）：**

```js
import Vue from 'vue'
import Router from 'vue-router'
　　/* 此处省去之前导入的HelloWorld模块 */
Vue.use(Router)

export default new Router({
  routes: [
    {
      path: '/',
      name: 'HelloWorld',
      component: resolve=>(require(["@/components/HelloWorld"],resolve))
    }
  ]
})
```

**路由懒加载（ES import实现）：**

```js
import Vue from 'vue'
import Router from 'vue-router'

Vue.use(Router)

const HelloWorld = ()=>import("@/components/HelloWorld")
export default new Router({
  routes: [
    {
      path: '/',
      name: 'HelloWorld',
      component:HelloWorld
    }
  ]
})
```

**组件懒加载（const实现）：**

```vue
<template>
  <div class="hello">
  <One-com></One-com>
  1111
  </div>
</template>

<script>
const One = ()=>import("./one");
export default {
  components:{
    "One-com":One
  },
  data () {
    return {
      msg: 'Welcome to Your Vue.js App'
    }
  }
}
</script>
```

**组件懒加载（异步方法实现）：**

```vue
<template>
  <div class="hello">
  <One-com></One-com>
  1111
  </div>
</template>

<script>
export default {
  components:{
    "One-com":resolve=>(['./one'],resolve)
  },
  data () {
    return {
      msg: 'Welcome to Your Vue.js App'
    }
  }
}
</script>
```

#### 生命周期

所有的生命周期钩子自动绑定 `this` 上下文到实例中，因此你可以访问数据，对 property 和方法进行运算。
这意味着**你不能使用箭头函数来定义一个生命周期方法** (例如 `created: () => this.fetchTodos()`)。这是因为箭头函数绑定了父上下文，因此 `this` 与你期待的 Vue 实例不同，`this.fetchTodos` 的行为未定义。

https://segmentfault.com/a/1190000011381906

https://cn.vuejs.org/v2/api/#created

![VueLifeCycle](D:\易事特工作\Vue学习\VueLifeCycle.png)

#### 表单的增删改查

- https://blog.csdn.net/dengdengchen/article/details/100131011
- https://blog.csdn.net/weixin_45416217/article/details/102967752?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param

#### 导入文件路径

- `./`：指当前目录
- `../`：指当前目录的上一层目录
- `@`：以根目录的方式定义相对路径

#### 组件化

使用`Vue.component()`函数创建自定义组件，第一个参数`name`是组件的名称，例如`Vue.component('counter_button'，….)`，则该组件名称为`counter_button`。随后还可以设置组件的属性`props`、值`data`、模板`template`等。

##### Prop

`prop`是我们在注册组件时自定义的一些属性attribute，在使用组件时，可以直接使用。当一个值传递给`prop`attribute时，它就变成的那个组件实例的property。例如设置`props: [‘title’]`，则在调用`counter_button`时，可以将`title`作为该标签的属性使用，`<button_counter title="counter"></button_counter>`。

##### Data

`data`必须是个函数，这是因为组件是能被复用的，相互之间组件的数据独立，为了保证实例可以维护一份独立的数据，使用函数来避免影响到其他所有实例。

##### Template

模板定义了该组件的表现形式。在创建模板时必须注意，一个组件的模板必须具备一个根节点，例如：

```javascript
template: '<div>
			<h1>it is a button</h1>
			<button v-on:click="counter++">You clicked me {{counter}} times.
             </button>
		   </div>',
```

否则，组件将不显示<button>标签的内容而只显示<h1>。模板内可以通过<solt></solt>标签声明一个组件的插槽，在组件标签内部可以自定义一些html内容。

一个组件默认可以有任意数量的prop，任何值都可以传递给任何prop。

### 语法

#### {a} = b含义

当`对象b`中有名为`a`的属性时，使用`const {a} = b`写法作为`const a = b.a`的简写，相当于将`a`从`对象b`中拎出来。

#### {} === {}为什么是false？

因为在`JavaScript`中，对象属于引用数据类型，例如`let a = {}`，实际上a的值是指向空对象的存储地址的指针，且`JavaScript`对比对象是通过它的指针来对比的，指向的地址一致，则为`true`，因此两个空对象相比较的结果还是`false`。

另外，补充一下堆（heap）栈（stack）的概念和`js`的数据类型。

**栈：****后进先出**，**自动分配**内存空间，由系统**自动释放**；使用的是**一级缓存**，他们通常都是被调用时处于存储空间中，调用完立即释放。

**堆：**队列优先，先进先出；**动态分配**内存，大小不定也**不会自动释放**；存放在**二级缓存**中，生命周期由虚拟机的垃圾回收算法来决定；一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。

基本数据类型（Undefined / Null / Boolean / Number / String）直接按值存放，存放在**栈内存**中；引用数据类型（对象 / 数组 / 函数）存放在**堆内存**中，，**首先从栈中获得该对象的地址指针，然后再从堆内存中取得所需的数据**。

#### 获取对象属性个数

直接上代码：

```js
let obj = {
	one: 1,
	two: 2,
	three: 3
}

// 两种方法获取属性个数
Object.getOwnPropertyNames(obj).length  
Object.keys(obj).length
```

#### Map对象

**`Map`** 对象保存键值对，并且能够记住键的原始插入顺序。任何值(对象或者[原始值](https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive)) 都可以作为一个键或一个值。

**创建Map对象**

`Map`对象是一个**二维数组**，且**键在前，值在后，按键找值**

```js
let map = new Map([
	[0, '中国'],
	[1, '美国'],
	[2, '日本'],
	[3, '俄罗斯'],
])
map // Map(4) {0 => "中国", 1 => "美国", 2 => "日本", 3 => "俄罗斯"}
```

**按键找值**

```js
map.get(0) // 中国
```

#### ==和===

**==**代表弱比较，**===**代表强比较

弱比较时，先检查两个操作数数据类型，若相同，则进行强比较；若不同，则对操作数进行一次类型转换，然后再强比较

强比较时，若操作数数据类型不同，则直接返回`false`

```js
null == undefined // true
1 == '1' // true
1 == [1] // true
1 == true // true
null === undefined // false
null === null // true
undefined === undefined // true
```

#### js进制转换

**十进制转换为二进制**

```js
var num = 100
console.log(num.toString(2))
```

语法

```js
NumberObject.toString(radix);
```

其中，`radix`为可选。规定表示数字的基数，使 `2 ~ 36` 之间的整数。若省略该参数，则使用基数 `10`。但是要注意，如果该参数是 `10` 以外的其他值，则 `ECMAScript` 标准允许实现返回任意值。

返回值

数字的字符串。例如，当 `radix` 为 `2` 时，`NumberObject` 会被转换为二进制值表示的字符串。

**二进制转换为十进制**

```js
var num = 1100100;
console.log(parseInt(num,2));
```

`parseInt()` 函数可解析一个字符串，并返回一个整数。

**语法**

```js
parseInt(string, radix);
```

其中，`string`为必需。要被解析的字符串。`radix`为可选。表示要解析的数字的基数。该值介于 `2 ~ 36` 之间。如果省略该参数或其值为 `0`，则数字将以 `10` 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 `16` 为基数。如果该参数小于 `2` 或者大于 `36`，则`parseInt()` 将返回 `NaN`。

**返回值**

返回解析后的数字。

```js
parseInt(num,8);   //八进制转十进制
parseInt(num,16);   //十六进制转十进制
parseInt(num).toString(8)  //十进制转八进制
parseInt(num).toString(16)   //十进制转十六进制
parseInt(num,2).toString(8)   //二进制转八进制
parseInt(num,2).toString(16)  //二进制转十六进制
parseInt(num,8).toString(2)   //八进制转二进制
parseInt(num,8).toString(16)  //八进制转十六进制
parseInt(num,16).toString(2)  //十六进制转二进制
parseInt(num,16).toString(8)  //十六进制转八进制
```

#### instanceof

`instanceof` **运算符**用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上。

**语法：**

```js
object instanceof constructor

`object`：某个实例对象   `constructor`：某个构造函数

用来检测  `constructor.prototype `是否存在于参数  `object` 的原型链上。
```



#### ${}模板字符串

使用模板字符串可以便捷地在字符串中衔接想要的数据，弥补了用`+`拼接字符串和数据的不便。

```html
<p>
    {{ `这是一个${value}示例` }}
</p>
```

```js
data() {
    return {
        value: '模板字符串'
    }
}
```

效果

```html
这是一个模板字符串示例
```

**注意：** **模板字符串的包裹符为  ``  而不是  ''  **

#### data下的this指向问题

```html
<!-- 注意这里的方法绑定的不是methods，而是data里的值 -->
<button @click="toFnThis"></button>
```

```js
data() {
    console.log(this) // VueComponent {_uid: 180, _isVue: true, $options: {…}, _renderProxy: Proxy, _self: VueComponent, …}
    return {
        toFnThis: this.fnThis // 方法后不加()
    }
},
methods: {
	fnThis() {
        console.log(this) // VueComponent {_uid: 101, _isVue: true, $options: {…}, _renderProxy: Proxy, _self: VueComponent, …}
    }
}
```

`data`方法下的`this`指向的是`vue`实例，`return`下`this`可指向实例中的方法，`html`调用`data`下的值即可。

#### 执行语句间&&

执行语句之间用`&&`连接，代表`&&`前的语句先判断，如果为`true`，才执行后面的语句。例如：

```js
let obj = {
    func: res => {
        console.log(res)
    }
}

ojb.func && obj.func('has attribute func') // 先判断obj中是否有func属性，再执行该函数
```

#### 解构函数参数({name: 'lisi'})

在函数传参的时候，可以通过参数解构写法传参，便于使用者阅读，明确知道函数的某一参数是否是对象类型。

**注意！使用参数解构写法，调用函数时传入参数属性名必须和解构中的名称一致，否则undefined！**

```js
function abc(val, {name, age}) {
    console.log(val, name, age)
}
var obj = {
    name: 'lisi',
    age: 22
}
var t = abc('zifuchuan', {name: 'zhangsan', age: 10}) // zifuchuan zhangsan 10
var r = abc('zifuchuan', obj) // zifuchuan lisi 22
```

另外，结构写法还可以用来方便地获取

#### 对象展开运算符（...）

`ES6`新特性之一，使用`...`可以展开数组，返回原序数组的每一个值，这样就不需要`apply`方法来将数组转为函数的参数了。

```js
const a = [
  {
    name: 'zhangsan',
    age: 22
  }, 2, 3, 4, 'zifuchuan', 'zifuzifu'
]
console.log(...a) // {name: "zhangsan", age: 22} 2 3 4 "zifuchuan" "zifuzifu"
```

#### js生成一个初始值为0-100的数组

```js
//实现方法一：循环赋值
var arr1 = new Array(100);
for(var i=0;i<arr1.length;i++){
  arr1[i] = i;
}
console.log(arr1);


//实现方法二：push方法实现
var arr2 = new Array();
for(var i=0;i<100;i++){
  arr2.push(i);
}
console.log(arr2);



//实现方法三：while
var arr3 = new Array();
var i = 0;
while(i<100){
  arr3.push(i);
  i++;
}
console.log(arr3);



//实现方法四：do while
var arr4 = new Array();
var i = 0;
do{
  arr4.push(i);
  i++;
}
while(i<100)
console.log(arr4);


//实现方法五：
var arr5 = Object.keys(Array.apply(null, {length:100})).map(function(item){

  return +item;

});
console.log(arr5);


//实现方法六：
var arr6 = Array.from({length:100}, (v,k) => k);
console.log(arr6);


//实现方法七：
var arr7 = Array.from(Array(100), (v,k) =>k);
console.log(arr7);


//实现方法八：
var arr8 = new Array(100).keys();
console.log(Array.from(arr8));


//实现方法九：
var arr9 = [];
var i = 0;
var timer = setInterval(function(){
  arr9[i] = i++;
  if(i>=100){
    clearInterval(timer);
    console.log(arr9);
  }
},1);


//实现方法十：
var arr = [];
var i = 0;
function MakeArray(num){
  if(i<num){
    arr[i] = i++;
    MakeArray(num);
  }
  return arr;
}
console.log(MakeArray(100));


//实现方法十一：
var arr11 = new Array(100).toString().split(',').map(function(item,index){
  return index;
});
console.log(arr11);
```

#### 数组深拷贝

（下面说的深拷贝是基本对象的深拷贝，不考虑对象的复杂属性，比如`set`，`get`，`Function`等）

1、最简单的方式 `JSON.parse(JSON.stringify(Obj))` 这种方法使用较为简单，可以满足基本的深拷贝需求，而且能够处理`JSON`格式能表示的所有数据类型，但是对于**正则表达式类型、函数类型等无法进行深拷贝**(而且会直接丢失相应的值)。

2、`jQuery`深拷贝 `var copiedObject = $.extend(true, {}, originalObject)`

3、手动写递归方式

```js
Copyvar array = [
   { number: 1 },
   { number: 2 },
   { number: 3 }
];
function copy (obj) {
        var newobj = obj.constructor === Array ? [] : {};
        if(typeof obj !== 'object'){
            return;
        }
        for(var i in obj){
           newobj[i] = typeof obj[i] === 'object' ? copy(obj[i]) : obj[i];
        }
        return newobj
}
var copyArray = copy(array)
copyArray[0].number = 100;
console.log(array); //  [{number: 1}, { number: 2 }, { number: 3 }]
console.log(copyArray); // [{number: 100}, { number: 2 }, { number: 3 }]
```

#### export default和export的区别

1. `export`与`export default`均可用于导出常量、函数、文件、模块等
2. 在一个文件或模块中，`export`、`import`可以有多个，`export default`仅有一个
3. 通过`export`方式导出，在导入时要加`{ }`，`export default`则不需要
4. 注意
   (1)输出**单个**值，使用`export default`
   (2)输出**多个**值，使用`export`
   (3)`export default`与普通的`export`**不要同时使用**

#### 逗号

表达式用逗号隔开时，表达式计算结果是最后一个子表达式的结果，但前面的表达式依然会执行。

```js
var a, b
a = (b = 1, 2)
a // 2
b // 1,因为执行了b = 1
```



#### js中，字符与ASCII码互相转换

大写字母**A-Z**对应的ASCII码值是**65-90**
小写字母a-z对应的ASCII码值是**97-122**
数字0-9对应的ASCII码值是**48-57**
中文正则表达式：**[\u4e00-\u9fa5]**

将字母转为ASCII码的方法：

```js
var str = "A";
str.charCodeAt();  // 65

var str1 = 'a';
str1.charCodeAt();  // 9712345
```

将ASCII码转为对应字母的方法：

```js
var num = 97;
String.fromCharCode(num);  // 'a'

var num1 = 100;
String.fromCharCode(num1);  // 'd'
```

#### js中，Array和Set相互转换

**array --> set （数组转set）**

```js
let array = [1, 2, 3, 4];
let set = new Set(array);
```

**set --> array** 

```js
let demo = new Set([1,2,3,4]);
Array.from(demo)
```

#### JavaScript中Set的使用

`Set`中存放的是**不会重复**的数据。

`Set`的定义：

```js
var set = new Set();
```

`Set`的遍历：

```js
set .forEach(function (element, sameElement, set) {
		console.log(element);
	}
```

`Set`的遍历方法：

> `Set` 提供了三个遍历器生成函数和一个遍历方法。

- keys()　　　　 返回一个键名的遍历器
- values()　　　 返回一个键值的遍历器
- entries()　　　 返回一个键值对的遍历器
- forEach()　　　使用回调函数遍历每个成员

`Set`的操作方法：

- add(value)　　　　添加数据，并返回新的 Set 结构
- delete(value)　　　删除数据，返回一个布尔值，表示是否删除成功
- has(value)　　　　查看是否存在某个数据，返回一个布尔值
- clear()　　　　　　清除所有数据，没有返回值

1. 与数组之间的转换

   1. 数组转`Set`

      ```js
      var arr = ["1","2","1","2","3","1"];
      var set = new Set(arr);
      //得到一个新的Set：{"1","2","3"};
      ```

   2. `Set`转数组

      ```js
      var arr1= Array.from(set );
      //得到一个新的数组：["1","2","3"];
      ```

2. 使用`Set`给数组去重

   ```js
   //定义一个新的数组：
   var arr = ["1","2","1","2","3","1"];
   ```

   - 方法一：

     ```js
     var arr1 = Array.from(new Set(arr));
     //得到一个新的数组：["1","2","3"];
     ```

   - 方法二：

     ```js
     var arr1 = [...new Set(arr)];
     //得到一个新的数组：["1","2","3"];
     ```

3. 求两个`Set`的并集、交集、差集

   ```js
   var arr1 = ["1","2","3"];
   var arr2 = ["1","2"];
   var set1= new Set(arr1);
   var set2= new Set(arr2);
   
   //并集后：
   var newSet1 = new Set([...set1,...set2]);
   //得到一个新的Set：{"1","2","3"};
   
   //交集后：
   var newSet2 = new Set([...set1].filter(x => set2.has(x)));
   //得到一个新的Set：{"1", "2"};
   
   //差集后：
   var newSet3 = new Set([...set1].filter(x => !set2.has(x)));
   //得到一个新的Set：{"3"};
   ```

#### Vue自定义指令

```vue

1.创建局部指令
var app = new Vue({
    el: '#app',
    data: {    
    },
    // 创建指令(可以多个)
    directives: {
        // 指令名称
        dir1: {
            inserted(el) {
                // 指令中第一个参数是当前使用指令的DOM
                console.log(el);
                console.log(arguments);
                // 对DOM进行操作
                el.style.width = '200px';
                el.style.height = '200px';
                el.style.background = '#000';
            }
        }
    }
})
 
2.全局指令
Vue.directive('dir2', {
    inserted(el) {
        console.log(el);
    }
})
 
3.指令的使用
<div id="app">
    <div v-dir1></div>
    <div v-dir2></div>
</div>
```

#### js闭包（未整理完）

**思考：**

```js
　　var name = "The Window";

　　var object = {
　　　　name : "My Object",

　　　　getNameFunc : function(){
　　　　　　return function(){
　　　　　　　　return this.name;
　　　　　　};

　　　　}

　　};

　　alert(object.getNameFunc()()); // The Window
```

```js
　　var name = "The Window";

　　var object = {
　　　　name : "My Object",

　　　　getNameFunc : function(){
　　　　　　var that = this;
　　　　　　return function(){
　　　　　　　　return that.name;
　　　　　　};

　　　　}

　　};

　　alert(object.getNameFunc()()); // My Object
```

> `Javascript`语言特有的"链式作用域"结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。

第一题中，this的指向层层向上寻找，最终找到当前`js`实例，指向的是`var name = "The Window";`

第二题中，`this`的指向往上一层即找到，在`getNameFunc`的匿名函数中被`that`存储，因此指向的是`object`对象的`name`。

```js
var throttle = (function() {
	var context = this
	console.log('out', context)
	return function () {
		console.log('in', context)
	}
})()
throttle() // out Window {window: Window, self: Window, document: document, name: "", location: Location, …}
//in Window {window: Window, self: Window, document: document, name: "", location: Location, …}

/**************************************/

var throttle = function() {
	var context = this
	console.log('out', context)
	return function () {
		console.log('in', context)
	}
}
throttle() // 只有“out”，不执行内函数
```

```js
function f1(){
　　var n = 999
　　nAdd = function() { n += 1 }
　　function f2() {
　　　　console.log(n)
　　}
　　return f2
}
var result = f1()
result() // 999

/************************************/

var result = function f1(){
　　var n = 999
　　nAdd = function() { n += 1 }
　　function f2() {
　　　　console.log(n)
　　}
　　return f2
}
result() // 不执行内函数
```

#### js取小数后两位

**四舍五入**

```js
var num =2.446242342;
num = num.toFixed(2); // 输出结果为 2.45
```

**不四舍五入**

第一种，先把小数边整数：

```js
Math.floor(15.7784514000 * 100) / 100 
// 输出结果为 15.77
```

第二种，当作字符串，使用正则匹配：

```js
Number(15.7784514000.toString().match(/^\d+(?:\.\d{0,2})?/)) 
// 输出结果为 15.77,不能用于整数如 10 必须写为10.0000
```

注意：如果是负数，请先**转换为正数**再计算，最后转回负数

#### js中Date与timestamp（时间戳）的相互转换

https://www.cnblogs.com/willingtolove/p/9544877.html

**时间(Date)转时间戳(Timestamp)：**

```js
var timestamp2 = new Date().getTime();
```

**时间戳(Timestamp)转时间(Date)：**

```js
var date1 = new Date(1472048779952);
var date1 = new Date(new Date().getTime());
```

#### 文本间空格占位符

```tex
&#32; == 普通的英文半角空格

&#160; == &nbsp; == &#xA0; == no-break space （普通的英文半角空格但不换行）

&#12288; == 中文全角空格 （一个中文宽度）

&#8194; == &ensp; == en空格 （半个中文宽度）

&#8195; == &emsp; == em空格 （一个中文宽度）

&#8197; == 四分之一em空格 （四分之一中文宽度）

相比平时的空格（&#32;），nbsp拥有不间断（non-breaking）特性。即连续的nbsp会在同一行内显示。即使有100个连续的nbsp，浏览器也不会把它们拆成两行。
```

#### 获取dom宽度

```vue
<div id="dom_one" />

document.getElementById('dom_one').clientWidth
```

#### 获取屏幕宽度和高度

```vue
data() {
    return {
        screenWidth: document.body.clientWidth,     // 屏幕宽
        screeHeight: document.body.clientHeight,    // 屏幕高
    }
}
```

#### 判断变量a是否为undefined

```js
console.log(typeof a.city === 'undefined')
// true
```

#### 用变量调用变量

使用**eval()**函数

```js
var test_5 = []
eval('test_' + 5) // []
```

#### 动态生成变量（用变量命名变量）

有时候会遇到这样的问题：某个需求需要n个数组。在定义时，数组名称不相同用于区分，但是直接写：`var 'test_' + i =[]`，这样是不行的，因为定义时不能带有表达式。

- **曲线救国**

  在给对象的属性命名时是可以带有表达式的，因此：

  ```js
  let mutivar = {}
  for (let i = 0; i < 5; i++) {
  	mutivar['test_'+i] = []
  }
  ```

  这种方式生成的变量都在`mutivar`对象里，不够独立。

- **window[name]**

  ```js
  let arr = []
  for (let i = 0; i < 5; i++) {
       let name = 'test_' + i
       window[name] = [i]
       arr.push(window[name])
  }
  ```

  `window`用**中括号**的方式定义 变量时，中括号里的内容应该是**字符串**。如果是一个**变量**的话，他就会解析这个变量找到具体的值。

- **数组**，但这种方法只能实现动态数量，不能实现自定义变量名

  ```js
  let brr = []
  for (let i = 0; i < 5; i++) {
       brr[i] = []
  }
  ```

**所有代码：**

```js
switch(num) {
        case 0:
          let mutivar = {}
          for (let i = 0; i < 5; i++) {
            mutivar['test_'+i] = []
          }
          console.log(mutivar) // {test_0: Array(0), test_1: Array(0), test_2: Array(0), test_3: Array(0), test_4: Array(0)}
        break
        case 1:
          let arr = []
          for (let i = 0; i < 5; i++) {
            let name = 'test_' + i
            window[name] = [i]
            arr.push(window[name])
          }
          console.log(test_3) // [3]
        break
        case 2:
          let brr = []
          for (let i = 0; i < 5; i++) {
            brr[i] = []
          }
          console.log(brr) // [Array(0), Array(0), Array(0), Array(0), Array(0)]
        break
        default: break
      }
```

#### !和!!

**!**

js中`!`的用法是比较灵活的，它除了做逻辑运算常常会用`！`做类型判断，可以用`！`与上对象来求得一个布尔值。

1. `！`可将变量转换成*boolean*类型，*null*、*undefined*和空字符串取反都为`false`，其余都为`true`。

   ```js
   !null=true
   
   !undefined=true
    
   !''=true
    
   !100=false
    
   !'abc'=false
   ```

   

2. `！！`常常用来做类型判断，在第一步`!`（变量）之后再做逻辑取反运算，在js中新手常常会写这样臃肿的代码：
   判断变量a为非空，未定义或者非空串才能执行方法体的内容

   ```js
   var a;
   if(a!=null&&typeof(a)!=undefined&&a!=''){
       //a有内容才执行的代码  
   }
   ```

   实际上我们只需要写一个判断表达：

   ```js
   if(!!a){
       //a有内容才执行的代码...  
   }
   ```

就能和上面达到同样的效果。a是有**实际含义的变量**才执行方法，否则变量*null*，*undefined*和`''`空串都不会执行以下代码。

可以总结出来，“`！`”是逻辑与运算，并且可以与任何变量进行逻辑与将其转化为布尔值，“`!!`”则是逻辑与的取反运算，尤其后者在判断类型时代码简洁高效，省去了多次判断*null*、*undefined*和*空字符串*的冗余代码。

#### ${}

用于字符串拼接，使用`${}`时，外部应该使用**反单引号**（键盘1左边）括起来而不是单引号。

```js
let a='Karry Wang';

let str=`I love ${a}, because he is handsome.`;
//注意：这行代码是用返单号引起来的

alert(str);
```

#### 比较两个数组元素是否相同

设两个数组`a=[1,2]`，`b=[1,2]` 。若直接==判断，结果为`false`

```js
a == b // false
```

应该先转化成字符串再比较

```js
a.toString() == b.toString() // true
```

若不计排序，要比较两数组里是否有同样的元素，则应该先排序后再比较

```js
a.sort().toString() == b.sort().toString() // true
```



#### Object.keys(object)

得到对象object的属性名称数组。

```js
var ob = {
          id: 1,
          subs: [{}, { id: 2, subs: [] }],
          name: 'iii'
        }
console.log(Object.keys(ob))	//["id", "subs", "name"]
```



#### 给对象新增属性 

使用Vue的全局API：**this.$set()**

```javascript
data() {
    return {
        a: {
            name: 'Im a'
        }
    }
}
methods: {
    addObject(){
        this.$set(a, 'value', 'Im value of a')
    }
}

```

#### this.$route和this.$router

**区别**

通过注入路由器，我们可以在任何组件内通过 this.$router 访问路由器，也可以通过 this.$route 访问当前路由

this.$router 相当于一个全局的路由器对象，包含了很多属性和对象（比如 history 对象），任何页面都可以调用其 push(), replace(), go() 等方法。

this.$route 表示当前路由对象，每一个路由都会有一个 route 对象，是一个局部的对象，可以获取对应的 name, path, params, query 等属性。

想要导航到不同的 URL，则使用 router.push 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。

当你点击 时，这个方法会在内部调用，所以说，点击 等同于调用 router.push(...)。

**this.$router详解**

- **this.$router.push()**

```javascript
Copy//url字符串
this.$router.push('/home')

//对象
this.$router.push({path:'home'})

//命名的路由
this.$router.push({name:'user', params:{userId: '123'}})

//带查询参数，变成 /register?plan=private
this.$router.push({path:'register', query:{plan:private}})
```

**注意：如果提供了 path，params 会被忽略，**上述例子中的 query 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 name 或手写完整的带有参数的 path：

```javascript
Copyconst userId = '123';
 
this.$router.push({path:`/user/${userId}`});  //->/user/123

this.$router.push({name:'user', params:{userId}});  //->/user/123

//这里的 params 不生效
this.$router.push({path:'/user', params:{userId}});  //->/user
```

同样的规则也适用于 router-link 组件的 to 属性。

**总结：**

params 传参，push 里面只能是 name:'xxx'，不能是 path:'/xxx'，因为 params 只能用 name 来引入路由，如果这里写成了 path ，接收参数页面会是 undefined。

**路由传参的方式：**

```javascript
Copy//手写完整的 path:
this.$router.push({path: `/user/${userId}`});
//获取参数：
this.$route.params.userId

//用 params 传递：
this.$router.push({name:'user', params:{userId: '123'}});
//获取参数：
this.$route.params.userId

//url 形式：url 不带参数，http:localhost:8080/#/user

//用 query 传递：
this.$router.push({path:'/user', query:{userId: '123'}});
//获取参数：
this.$route.query.userId
//url 形式：url 带参数，http:localhost:8080/#/user?userId=123
```

**直白的说，query 相当于 get 请求，页面跳转的时候可以在地址栏看到请求参数，params 相当于 post 请求，参数不在地址栏中显示。**

要注意，以 / 开头的嵌套路径会被当作根路径。 这让你充分的使用嵌套组件而无须设置嵌套的路径。

- **this.$router.replace()**

描述：同样是跳转到指定的url，但是这个方法不会向history里面添加新的记录，点击返回，会跳转到上上一个页面。上一个记录是不存在的。

- **this.$router.go(n)**

相对于当前页面向前或向后跳转多少个页面,类似 window.history.go(n)。n可为正数可为负数。正数返回上一个页面

```javascript
Copy//前进一步，等同于history.forward()
router.go(1)

//后退一步，等同于history.back()
router.go(-1)

//前进3步
router.go(3)

//如果history记录不够用，就默默
```

#### **组件之间的传值**

https://www.cnblogs.com/shenpeng/p/13157561.html

组件之间的传值，我们比较常用到的是props/$emit

1、父组件向子组件传值--props

这里我们在父组件中定义的extensionObj是一个对象

```javascript
<Extension :extensionObj="extensionObj"/>
data(){
    return{
        extensionObj: {},
    }
}
```

在子组件中接收值

```javascript
props:['extensionObj'],
```

或者

```javascript
props:{
    extensionObj: {
        type: Object,
        default: {}
    },
},
```

2、子组件向父组件传值

子组件：

```vue
<col @click="tableClickBtn(item)"></col>
```

写个方法触发

```js
tableBtnClick(item){
    this.$emit('select',item);
}
```

父组件：

```vue
<StaffDialog ref="staffDialogRef" @select="staffDialogSelect"/>
```

写个方法接收

```js
staffDialogSelect(item) {
    this.searchObj = item;
}
```

#### $nextTick

Vue中的`nextTick`涉及到Vue中DOM的异步更新。

　　Vue.nectTick() 是在下次DOM更新循环结束之后执行延迟回调，在修改数据之后使用$nextTick，则可以在回调中获取更新后的DOM（dom的改变是发生在nextTick()之后），这个方法作用是当数据被修改后使用这个方法，会回调获取更新后的dom再render出来

　　Vue.nextTick()作用：在下次dom更新循环结束之后，执行延迟回调。在修改数据之后立即使用这个方法，获得更新后的dom

**在以下两个情况下需要用到Vue.nextTick()**

1、Vue声明周期的created() 钩子函数进行的DOM操作一定要放在Vue.nextTick() 的回调函数中，因为created() 执行的时候DOM实际上并未进行任何渲染，此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。

　　与之对应的就是mounted 钩子函数，因为该函数执行时所有的DOM挂载和渲染都已完成，此时再钩子函数中进行任何DOM操作都不会有问题。

2、在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作应该放进Vue.nextTick() 的回调函数中

简而言之，如果你在数据改变之后的操作跟改变之后的DOM有关，那么就应该使用Vue.nextTick()

例子：

**模板**

```html
<div class="app">
  <div ref="msgDiv">{{msg}}</div>
  <div v-if="msg1">Message got outside $nextTick: {{msg1}}</div>
  <div v-if="msg2">Message got inside $nextTick: {{msg2}}</div>
  <div v-if="msg3">Message got outside $nextTick: {{msg3}}</div>
  <button @click="changeMsg">
    Change the Message
  </button>
</div>
```

**Vue实例**

```javascript
new Vue({
  el: '.app',
  data: {
    msg: 'Hello Vue.',
    msg1: '',
    msg2: '',
    msg3: ''
  },
  methods: {
    changeMsg() {
      this.msg = "Hello world."
      this.msg1 = this.$refs.msgDiv.innerHTML
      this.$nextTick(() => {
        this.msg2 = this.$refs.msgDiv.innerHTML
      })
      this.msg3 = this.$refs.msgDiv.innerHTML
    }
  }
})
```

**点击前**

```
Hello Vue.
```

**点击后**

```
Hello world.
Message got outside $nextTick: Hello Vue.
Message got inside $nextTick: Hello world.
Message got outside $nextTick: Hello Vue.
```



#### switch语句

```javascript
switch(表达式) {
     case n:
        代码块
        break;
     case n:
        代码块
        break;
     default:
        默认代码块
} 
```

#### 计算属性

模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。例如：

```html
<div id="example">
  {{ message.split('').reverse().join('') }}
</div>
```

在这个地方，模板不再是简单的声明式逻辑。你必须看一段时间才能意识到，这里是想要显示变量 `message` 的翻转字符串。当你想要在模板中多包含此处的翻转字符串时，就会更加难以处理。

所以，对于任何复杂逻辑，你都应当使用**计算属性**。

**[基础例子](https://cn.vuejs.org/v2/guide/computed.html#基础例子)**

```html
<div id="example">
  <p>Original message: "{{ message }}"</p>
  <p>Computed reversed message: "{{ reversedMessage }}"</p>
</div>
```

```javascript
var vm = new Vue({
  el: '#example',
  data: {
    message: 'Hello'
  },
  computed: {
    // 计算属性的 getter
    reversedMessage: function () {
      // `this` 指向 vm 实例
      return this.message.split('').reverse().join('')
    }
  }
})
```

结果：

```html
Original message: "Hello"

Computed reversed message: "olleH"
```

这里我们声明了一个计算属性 `reversedMessage`。我们提供的函数将用作 property `vm.reversedMessage` 的 getter 函数：

```javascript
console.log(vm.reversedMessage) // => 'olleH'
vm.message = 'Goodbye'
console.log(vm.reversedMessage) // => 'eybdooG'
```

你可以打开浏览器的控制台，自行修改例子中的 vm。`vm.reversedMessage` 的值始终取决于 `vm.message` 的值。

你可以像绑定普通 property 一样在模板中绑定计算属性。Vue 知道 `vm.reversedMessage` 依赖于 `vm.message`，因此当 `vm.message` 发生改变时，所有依赖 `vm.reversedMessage` 的绑定也会更新。而且最妙的是我们已经以声明的方式创建了这种依赖关系：计算属性的 getter 函数是没有副作用 (side effect) 的，这使它更易于测试和理解。

**计算属性缓存 vs 方法**

你可能已经注意到我们可以通过在表达式中调用方法来达到同样的效果：

```js
<p>Reversed message: "{{ reversedMessage() }}"</p>
// 在组件中
methods: {
  reversedMessage: function () {
    return this.message.split('').reverse().join('')
  }
}
```

我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是**计算属性是基于它们的响应式依赖进行缓存的**。只在相关响应式依赖**发生改变时**它们才会重新求值。这就意味着只要 `message` 还没有发生改变，多次访问 `reversedMessage` 计算属性会立即返回之前的计算结果，而**不必再次执行函数**。

这也同样意味着下面的计算属性将不再更新，因为 `Date.now()` 不是响应式依赖：

```js
computed: {
  now: function () {
    return Date.now()
  }
}
```

相比之下，每当触发重新渲染时，调用方法将**总会**再次执行函数。

我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 **A**，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 **A**。如果没有缓存，我们将不可避免的多次执行 **A** 的 getter！如果你不希望有缓存，请用方法来替代。

**计算属性 vs 侦听属性**

Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：**侦听属性**。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 `watch`——特别是如果你之前使用过 AngularJS。然而，通常更好的做法是使用计算属性而不是命令式的 `watch` 回调。细想一下这个例子：

```
<div id="demo">{{ fullName }}</div>
var vm = new Vue({
  el: '#demo',
  data: {
    firstName: 'Foo',
    lastName: 'Bar',
    fullName: 'Foo Bar'
  },
  watch: {
    firstName: function (val) {
      this.fullName = val + ' ' + this.lastName
    },
    lastName: function (val) {
      this.fullName = this.firstName + ' ' + val
    }
  }
})
```

上面代码是命令式且重复的。将它与计算属性的版本进行比较：

```
var vm = new Vue({
  el: '#demo',
  data: {
    firstName: 'Foo',
    lastName: 'Bar'
  },
  computed: {
    fullName: function () {
      return this.firstName + ' ' + this.lastName
    }
  }
})
```

好得多了，不是吗？

**计算属性的 setter**

计算属性默认只有 getter，不过在需要时你也可以提供一个 setter：

```
// ...
computed: {
  fullName: {
    // getter
    get: function () {
      return this.firstName + ' ' + this.lastName
    },
    // setter
    set: function (newValue) {
      var names = newValue.split(' ')
      this.firstName = names[0]
      this.lastName = names[names.length - 1]
    }
  }
}
// ...
```

现在再运行 `vm.fullName = 'John Doe'` 时，setter 会被调用，`vm.firstName` 和 `vm.lastName` 也会相应地被更新。

#### |和&

**“ | ”**和**“ & ”**运算符表示位运算，运算结果是**二进制数**

```c
6&3=110&011=010=2
6|3=110|011=111=7
```

#### res[i] = chars[0 | Math.random() * chars.length]

表示：
res数组的第i位的值为：chars数组中的任意一个值。
下标值：范围在0到chars数组长度之间
**0 | Math.random() * chars.length**：随机数是带小数的，但与0进行“与运算”后，值变为了整数。

#### a[index] = i < 6;

数组`a[]`的值为*boolean*类型，语句的意思是：判断`i`是否小于6，若小于，则`a[index]`的值为`true`，反之为`false`。

尽量写成：`a[index] = (i < 6);`

#### var

用var命令声明的变量，是在全局范围内有效的，例如：

```javascript
var a = [];
for (var i = 0; i < 10; i++) {
   a[i] = function () {
     console.log(i);
   };
 }
 a[6]();	//10
```

上面这段代码中，循环变量`i`是用`var`命令声明的，因此是在全局范围内都有效，所以全局只有一个变量`i`。每一次循环，变量`i`的值都会发生改变，而循环内被赋给数组`a`的函数内部的`console.log(i)`，里面的`i`指向的就是全局的`i`。也就是说，所有数组`a`的成员里面的`i`，指向的都是同一个`i`，导致运行结束后，输出的`i`的值是 10，而不是6。

#### let

`let`声明，只是在代码块中有效。如果上个循环中的`var`变成`let`声明，结果就大不一样了。

```javascript
var a = [];
for (let i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6]();	//6
```

这里的结果是6，因为~声明的变量，只是在当前循环的代码块中有效。

`let`不允许在相同的作用域内重复声明同一个变量；但是可以在块级作用域中的声明，

```javascript
function func(test) {
  let test; // 报错
}

function func(test) {
  {
    let test; // 不报错
  }
}
```

#### const

`const`声明一个只读的常量。所谓常量，即一旦声明，值就**不能改变**。

`const`声明的变量不能改变值，这说明，`const`一旦声明变量，就必须**立即初始化**，不能留到以后赋值。

`const`的作用域与`let`相同：只在声明所在的**块级作用域**内有效。

#### { a : b }

`var o={ a : 1, b : 2 }`

表示声明一个变量，*o*是变量名称，`{}`表示一个对象，其中*a*,*b*是这个对象的两个属性，值分别为1和2。

#### 三元表达式

语法：`boolean? true : false`
例如： `a? 100 : b? 50 : 0`
含义：条件满足a吗？如果满足返回100，否则，条件满足b吗？如果满足，返回50，否则返回0。

```java
if(a){
    Return 100;
}else if(b){
    Return 50;
}else{
    Return 0;
}
```

#### 引入并调用组件

使用组件：
`<add-or-update v-if="addOrUpdateVisible" @refreshDataList="getData" />`

引入包：
`import AddOrUpdate from './station-add-or-update'`

声明组件：

```javascript
components: {
    AddOrUpdate
},
```

*AddOrUpdate* 是对引入的文件进行命名，相当于变量名。然后在*component*中声明。在*template*中使用时，标签名可以是*AddOrUpdate* 字符串的变形，包括变换大小写，加“-”等。因此标签<add-or-update>等同于<AddOrUpdate>。

### 函数

#### sort()

**定义和用法**

sort() 方法用于对数组的元素进行排序。

排序顺序可以是字母或数字，并按升序或降序。

默认排序顺序为按字母升序。

**注意：**当数字是按字母顺序排列时"40"将排在"5"前面。

使用数字排序，你必须通过一个函数作为参数来调用。

函数指定数字是按照升序还是降序排列。

这些说起来可能很难理解，你可以通过本页底部实例进一步了解它。

**注意：** 这种方法会**改变原始数组**！

**语法**

`array.sort(sortfunction)`

**数组中的对象依照某个值进行排序**

数字排序：

```js
var points = [40,100,1,5,25,10];
points.sort(function(a,b){return a-b});

// 1,5,10,25,40,100
```

其中，`a`，`b`是依次从数组中取相邻两个元素，`a`的位置比`b`后。比如第一次取`100, 40`

当数组元素是对象时，也可以用上述方法对对象中的某个属性排序：

```js
var list = [
  {
    "onlineCourseId": 1507,
    "courseName": "资源管理的课程_120903",
    "courseType": "T07"
  },
  {
    "onlineCourseId": 1481,
    "courseName": "平台课程_02",
    "courseType": "T07"
  },
  {
    "onlineCourseId": 1462,
    "courseName": "平台课程",
    "courseType": "T07"
  },
  {
    "onlineCourseId": 1460,
    "courseName": "新的平台资源001",
    "courseType": "T07"
  }
]

// 对onlineCourseId进行排序（升序）：
list.sort(function (a, b) {
    return a.onlineCourseId - b.onlineCourseId
})
```

但是这种方法复用性低，每次都需要写一个方法，想要封装出公共方法，就要用到闭包结构了。

```js
// 这里定义一个比较方法
function compare(protoTypeName) {
  return function(a, b) { // 这样既可以获取到数据，又可以自定义传参
    return a.onlineCourseId - b.onlineCourseId
  }
}

// 直接使用封装好的方法
list.sort(compare('onlineCourseId'))
```

#### reduce()

**定义和用法**

`reduce()` 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。

`reduce()` 可以作为一个高阶函数，用于函数的 `compose`。

**注意:** `reduce()` 对于**空数组**是不会执行回调函数的。

**语法**

```js
array.reduce(function(total, currentValue, currentIndex, arr), initialValue)
```

**参数**

| 参数                                      | 描述                                                         |
| :---------------------------------------- | :----------------------------------------------------------- |
| *function(total,currentValue, index,arr)* | 必需。用于执行每个数组元素的函数。 <br />函数参数:<br />`total`*必需。*初始值*, 或者计算结束后的返回值*<br />`currentValue`*必需。当前元素<br />*`currentIndex`*可选。当前元素的索引*<br />`arr`*可选。当前元素所属的数组对象。 |
| *initialValue*                            | 可选。传递给函数的初始值                                     |

**例如：**

```js
let a = [1, 2, 3, 4, 5]
a.reduce((a, b) => {
    return a + b
}) // 15
```



#### some()

**定义和用法：**

`some()` 方法用于检测数组中的元素是否满足指定条件（**函数提供**）。

`some()` 方法会依次执行数组的每个元素：

- 如果有一个元素满足条件，则表达式返回`true` , 剩余的元素不会再执行检测。
- 如果没有满足条件的元素，则返回`false`。

**注意：** `some()` 不会对空数组进行检测。

**注意：** `some()` 不会改变原始数组。

**语法：**

```js
array.some(function(currentValue,index,arr),thisValue)
```

| 参数                                | 描述                                                         |
| :---------------------------------- | :----------------------------------------------------------- |
| *function(currentValue, index,arr)* | 必须。函数，数组中的每个元素都会执行这个函数<br />函数参数: <br />`currentValue`：必须。当前元素的值<br />`index`：可选。当前元素的索引值<br />`arr`：可选。当前元素属于的数组对象 |
| *thisValue*                         | 可选。对象作为该执行回调时使用，传递给函数，用作 "`this`" 的值。 如果省略了 `thisValue` ，"`this`" 的值为 "`undefined`" |

#### map()和filter()

`js`数组中，`map()`和`filter()`都是对数组的每一个元素进行操作。区别在于`map()`是对每个元素做一次**统一映射**，可能会**改变数组元素的值**，但不**会改变数组元素的个数**；`filter()`是对每个元素做一次**符合过滤条件的判断**，最终只有符合条件的元素留下，可能**会改变数组元素个数**，但**不会改变数组元素的值**。

```js
let a = [1, 2, 3, 4, 5]

// map()
a.map(e => {
    return e === 3 // [false, false, true, false, false], 依照条件返回每个元素的判断结果，元素个数不变
})

// filter()
a.filter(e => {
    return e === 3 // [3], 返回原数组中符合判断条件的元素，元素值不变
})

console.log(a) // [1, 2, 3, 4, 5], 不会改变原数组
```

**注：map()和filter()都不会改变原数组。**

#### find()

find() 方法返回通过测试（函数内判断）的数组的第一个元素的值。

find() 方法为数组中的每个元素都调用一次函数执行：

- 当数组中的元素在测试条件时返回 *true* 时, find() 返回符合条件的元素，之后的值不会再调用执行函数。
- 如果没有符合条件的元素返回 undefined

**注意:** find() 对于空数组，函数是不会执行的。

**注意:** find() 并没有改变数组的原始值。

```js
let arr =  [1, 2, 3, 4, 5]
console.log(arr.find(e => {
	return e >3
})) // 4，类型为Number
```

#### call(), apply(), bind()

三个函数都是用来**重定义this指向**的

```js
var obj = {
    myFunc: function (f, t) {
        console.log(this.name, f, t)
    }
}
var test = {
    name: 'lisi'
}
obj.myFunc.call(test, 'here', 'there') // lisi here there
obj.myFunc.apply(test, ['here', 'there']) // lisi here there
obj.myFunc.bind(test, 'here', 'there')() // lisi here there
obj.myFunc.bind(test, ['here', 'there']) // lisi here undefined
```

注意传参格式

#### match()

`match()` 方法可在字符串内**检索指定的值**，或找到一个或多个**正则表达式**的匹配。

该方法类似 `indexOf()` 和 `lastIndexOf()`，但是它返回**指定的值**，而不是字符串的位置。

**语法**

```js
stringObject.match(searchvalue)
stringObject.match(regexp)
```

| 参数        | 描述                                                         |
| :---------- | :----------------------------------------------------------- |
| searchvalue | 必需。规定要检索的字符串值。                                 |
| regexp      | 必需。规定要匹配的模式的 RegExp 对象。如果该参数不是 RegExp 对象，则需要首先把它传递给 RegExp 构造函数，将其转换为 RegExp 对象。 |

返回存放**匹配结果的数组**。该数组的内容依赖于 regexp 是否具有全局标志 **g**。

**例如：**

给定一个正整数，将其变为每三位标记一个逗号的计数形式。

```js
let num = 5489216776
function formatNumber(val) {
    let str = val.toString()
    let len = str.length
    if (len < 3) return str
    let r = len % 3
    return r > 0 ? str.slice(0, r) + ',' + str.slice(r, len).match(/\d{3}/g).join(',') : str.slice(r, len).match(/\d{3}/g).join(',')
}
formatNumber(num) // 5,489,216,776
```

**说明**

`match()` 方法将检索字符串 `stringObject`，以找到一个或多个与 `regexp` 匹配的文本。这个方法的行为在很大程度上有赖于 `regexp` 是否具有标志 **g**。

如果 `regexp` 没有标志 **g**，那么 `match()` 方法就只能在 `stringObject` 中**执行一次匹配**。如果没有找到任何匹配的文本， `match()` 将返回 `null`。否则，它将返回一个数组，其中存放了与它找到的匹配文本有关的信息。该数组的第 0 个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本。除了这些常规的数组元素之外，返回的数组还含有两个对象属性。`index` 属性声明的是匹配文本的起始字符在 `stringObject` 中的位置，`input` 属性声明的是对 `stringObject` 的引用。

如果 `regexp` 具有标志 g，则 `match()` 方法将执行全局检索，找到 `stringObject` 中的所有匹配子字符串。若没有找到任何匹配的子串，则返回 `null`。如果找到了一个或多个匹配子串，则返回一个数组。不过全局匹配返回的数组的内容与前者大不相同，它的数组元素中存放的是 `stringObject` 中所有的匹配子串，而且也没有 `index` 属性或 `input` 属性。

**注意：**在全局检索模式下，`match()` 即不提供与子表达式匹配的文本的信息，也不声明每个匹配子串的位置。如果您需要这些全局检索的信息，可以使用 `RegExp.exec()`。

#### prompt()

弹出输入框，可用格式为`prompt('提示语', 默认值)`，也可直接`prompt()`。

#### eval()

`eval()` 函数可计算某个字符串，并执行其中的的 *JavaScript* 代码。

语法

```js
eval(string)
```

#### indexOf()

用于判断数组内是否含有某个值

`array.indexOf(item,start)`：元素在数组中的位置,如果没与搜索到则返回 `-1`。其中，`item`为必须参数，为查找的元素；`start`为可选参数，规定在数组中开始检索的位置。

#### 异步函数async及await

`async`作为一个关键字放到函数前面，用于表示函数是一个异步函数，异步函数也就意味着该函数的执行不会阻塞后面代码的执行。

```js
async function timeout() {
　　return 'hello world';
}
```

语法很简单，就是在函数前面加上`async` 关键字，来表示它是异步的，那怎么调用呢？`async` 函数也是函数，平时我们怎么使用函数就怎么使用它，直接加括号调用就可以了，为了表示它没有阻塞它后面代码的执行，我们在`async` 函数调用之后加一句`console.log;`

```js
async function timeout() {
    return 'hello world'
}
timeout();
console.log('虽然在后面，但是我先执行');
```

执行结果：

```
虽然在后面，但是我先执行
```

`async` 函数 `timeout` 调用了，但是没有任何输出，它不是应该返回 `'hello world'`, 先不要着急， 看一看`timeout()`执行返回了什么？ 把上面的 `timeout()` 语句改为`console.log(timeout())`

```js
async function timeout() {
    return 'hello world'
}
console.log(timeout());
console.log('虽然在后面，但是我先执行');
```

执行结果：

```
>Promise {<resolved>: "hello world"}
虽然在后面，但是我先执行
```

原来`async`函数返回的是一个`promise`对象，如果要获取到`promise`返回值，我们应该用`then`方法，继续修改代码

```js
async function timeout() {
    return 'hello world'
}
timeout().then(result => {
    console.log(result);
})
console.log('虽然在后面，但是我先执行');
```

执行结果：

```
虽然在后面，但是我先执行
hello world
```

我们获取到了`'hello world'`, 同时`timeout`的执行也没有阻塞后面代码的执行，和我们刚才说的一致。

这时，你可能注意到控制台中的`Promise`有一个`resolved`，这是`async`函数内部的实现原理。如果`async`函数中有返回一个值 ,当调用该函数时，内部会调用Promise.solve()方法把它转化成一个`promise`对象作为返回，但如果`timeout`函数内部抛出错误呢？那么就会调用`Promise.reject()`返回一个`promise`对象， 这时修改一下`timeout`函数

```js
async function timeout(flag) {
    if (flag) {
        return 'hello world'
    } else {
        throw 'my god, failure'
    }
}
console.log(timeout(true))  // 调用Promise.resolve() 返回promise 对象。
console.log(timeout(false)); // 调用Promise.reject() 返回promise 对象。
```

执行结果：

```
>Promise {<resolved>: "hello world"}
>Promise {<rejected>: "my god, failure"}
```

如果函数内部抛出错误， `promise`对象有一个`catch`方法进行捕获。

```js
timeout(false).catch(err => {
    console.log(err)
})
```

`async`关键字差不多了，我们再来考虑`await`关键字，await是等待的意思，那么它等待什么呢，它后面跟着什么呢？其实它后面可以放任何表达式，不过我们更多的是放一个返回`promise`对象的表达式。注意`await`关键字只能放到`async`函数里面

现在写一个函数，让它返回`promise`对象，该函数的作用是2s 之后让数值乘以2

```js
// 2s 之后返回双倍的值
function doubleAfter2seconds(num) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve(2 * num)
        }, 2000);
    } )
}
```

现在再写一个`async`函数，从而可以使用`await`关键字， `await` 后面放置的就是返回promise对象的一个表达式，所以它后面可以写上`doubleAfter2seconds`函数的调用

```js
async function testResult() {
    let result = await doubleAfter2seconds(30);
    console.log(result);
}
```

```js
testResult();
```

打开控制台，2s之后，输出了60。

现在我们看看代码的执行过程，调用`testResult`函数，它里面遇到了`await`, await表示等一下，代码就暂停到这里，不再向下执行了，它等什么呢？等后面的`promise`对象执行完毕，然后拿到`promise resolve`的值并进行返回，返回值拿到之后，它继续向下执行。具体到 我们的代码, 遇到await 之后，代码就暂停执行了， 等待`doubleAfter2seconds(30)`执行完毕，`doubleAfter2seconds(30)`返回的`promise`开始执行，2秒 之后，`promise resolve`了， 并返回了值为60， 这时`await`才拿到返回值60， 然后赋值给`result`， 暂停结束，代码才开始继续执行，执行 `console.log`语句。

　　就这一个函数，我们可能看不出`async/await`的作用，如果我们要计算3个数的值，然后把得到的值进行输出呢？

```js
async function testResult() {
    let first = await doubleAfter2seconds(30);
    let second = await doubleAfter2seconds(50);
    let third = await doubleAfter2seconds(30);
    console.log(first + second + third);
}
```

6秒后，控制台输出220, 我们可以看到，写异步代码就像写同步代码一样了，再也没有回调地域了。

注意：

- `async` 和 `await` 基于 promise 的。 使用 `async`的函数将会始终返回一个 `promise`对象。 这一点很重要，要记住，这可能是你遇到的容易犯错的地。
- 在使用 `await` 的时候我们暂停了函数，而非整段代码。
- `async` 和 `await` 是非阻塞的。
- 你仍然可以使用 `Promise` 例如 `Promise.all()`。

#### typeof

`typeof`是一个运算符，有2种使用方式：`typeof(表达式)`和`typeof 变量名`，第一种是对表达式做运算，第二种是对变量做运算。

`typeof`运算符的返回类型为字符串，值包括如下几种：

1. 'undefined'       --未定义的变量或值
2. 'boolean'         --布尔类型的变量或值
3. 'string'           --字符串类型的变量或值
4. 'number'         --数字类型的变量或值
5.  'object'          --对象类型的变量或值，或者`null`(这个是js历史遗留问题，将`null`作为object类型处理)
6. 'function'         --函数类型的变量或值

#### Object.keys(obj)

返回对象obj的所有属性名称组成的字符串数组。

#### hasOwnProperty()

Object的`hasOwnProperty()`方法返回一个布尔值，判断对象是否包含特定的自身（非继承）属性。

**判断自身属性是否存在**

```js
var o = new Object();
o.prop = 'exists';

function changeO() {
  o.newprop = o.prop;
  delete o.prop;
}

o.hasOwnProperty('prop');  // true
changeO();
o.hasOwnProperty('prop');  // false
```

**判断自身属性与继承属性**

```js
function foo() {
  this.name = 'foo'
  this.sayHi = function () {
    console.log('Say Hi')
  }
}

foo.prototype.sayGoodBy = function () {
  console.log('Say Good By')
}

let myPro = new foo()

console.log(myPro.name) // foo
console.log(myPro.hasOwnProperty('name')) // true
console.log(myPro.hasOwnProperty('toString')) // false
console.log(myPro.hasOwnProperty('hasOwnProperty')) // fasle
console.log(myPro.hasOwnProperty('sayHi')) // true
console.log(myPro.hasOwnProperty('sayGoodBy')) // false
console.log('sayGoodBy' in myPro) // true
```

**遍历一个对象的所有自身属性**

在看开源项目的过程中，经常会看到类似如下的源码。`for...in`循环对象的所有枚举属性，然后再使用`hasOwnProperty()`方法来忽略继承属性。

```js
var buz = {
    fog: 'stack'
};

for (var name in buz) {
    if (buz.hasOwnProperty(name)) {
        alert("this is fog (" + name + ") for sure. Value: " + buz[name]);
    }
    else {
        alert(name); // toString or something else
    }
}
  
```

**注意 `hasOwnProperty` 作为属性名**

JavaScript 并没有保护 `hasOwnProperty` 属性名，因此，可能存在于一个包含此属性名的对象，有必要使用一个可扩展的`hasOwnProperty`方法来获取正确的结果：

```js
var foo = {
    hasOwnProperty: function() {
        return false;
    },
    bar: 'Here be dragons'
};

foo.hasOwnProperty('bar'); // 始终返回 false

// 如果担心这种情况，可以直接使用原型链上真正的 hasOwnProperty 方法
// 使用另一个对象的`hasOwnProperty` 并且call
({}).hasOwnProperty.call(foo, 'bar'); // true

// 也可以使用 Object 原型上的 hasOwnProperty 属性
Object.prototype.hasOwnProperty.call(foo, 'bar'); // true
```

#### slice()

slice() 方法可从已有的数组中返回选定的元素。slice（0, 2）返回数组下标为0，1的数组。

**语法**

```
arrayObject.slice(start,end)
```

| 参数  | 描述                                                         |
| :---- | :----------------------------------------------------------- |
| start | 必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。<br />倒数10个元素：`slice(-10)` |
| end   | 可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。 |

#### splice()

splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。

**注释：**该方法会改变原始数组。

**语法**

```
arrayObject.splice(index,howmany,item1,.....,itemX)
```

| 参数              | 描述                                                         |
| :---------------- | :----------------------------------------------------------- |
| index             | 必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。 |
| howmany           | 必需。要删除的项目数量。如果设置为 0，则不会删除项目。       |
| item1, ..., itemX | 可选。向数组添加的新项目。                                   |

#### watch监听

对vue中的数据变化进行监听，可以是数组或者对象或者单个数据。

同时监听多个数据：

```js
'stationList.longitude': function (val，old) {
      if (this.stationList.latitude !==null && val !==null) {
        this.getLocation(val, this.stationList.latitude)
      }
    },
    'stationList.latitude': function (val, old) {
      if (this.stationList.longitude !==null && val !==null) {
        this.getLocation(this.stationList.longitude, val)
      }
    }
```

通过if来限制条件执行。或者将数据封装成对象进行监听：

```js
data () {
      return {
      		name1: '',
      		name2: '',
      		age: ''
      }
 },
computed: {
      listenChange () {
        const {name1,name2} = this
        return {name1,name2}
      }
    },
    
    watch: {
      listenChange (val) {
      		console.log('listenChange :', val)
      		if (val.name1 === val.name2) {
            this.$set(this,'age',1)
        	 } else {
            	this.$set(this,'age',null)
          	}
      }
    }
```

但这种方式在属性复杂，需求多的时候，需要封装多个属性，维护困难。

#### shift（）

shift() 方法用于把数组的**第一个元素**从其中删除，并**返回第一个元素**的值。

**注意：** 此方法改变数组的长度！

**提示:** 移除数组末尾的元素可以使用 [pop()](https://www.runoob.com/jsref/jsref-pop.html) 方法。

#### unshift()

unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。

**注意：** 该方法将改变数组的数目。

**提示:** 将新项添加到数组末尾，请使用`push()`方法。

#### pop()

删除原数组最后一项并返回删除元素的值。

#### push（）

push() 方法可向数组的末尾添加**一个或多个**元素，并返回新的长度。

**注意：** 新元素将添加在数组的**末尾**。

**注意：** 此方法改变数组的长度。

**提示：** 在数组**起始位置**添加元素请使用 [unshift()](https://www.runoob.com/jsref/jsref-unshift.html) 方法。

#### indexOf()

**定义和用法**

indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。

**语法**

```
stringObject.indexOf(searchvalue,fromindex)
```

| 参数        | 描述                                                         |
| :---------- | :----------------------------------------------------------- |
| searchvalue | 必需。规定需检索的字符串值。                                 |
| fromindex   | 可选的整数参数。规定在字符串中开始检索的位置。它的合法取值是 0 到 stringObject.length - 1。如省略该参数，则将从字符串的首字符开始检索。 |

**说明**

该方法将从头到尾地检索字符串 `stringObject`，看它是否含有子串 `searchvalue`。开始检索的位置在字符串的 `fromindex` 处或字符串的开头（没有指定 `fromindex` 时）。如果找到一个 `searchvalue`，则返回 `searchvalue` 的第一次出现的位置。`stringObject` 中的字符位置是从 0 开始的。

**提示和注释**

注释：indexOf() 方法对**大小写敏感**！

注释：如果要检索的字符串值没有出现，则该方法返回 **-1**。

**实例**

在本例中，我们将在 "Hello world!" 字符串内进行不同的检索：

```js
<script type="text/javascript">

var str="Hello world!"
document.write(str.indexOf("Hello") + "<br />")
document.write(str.indexOf("World") + "<br />")
document.write(str.indexOf("world"))

</script>
```

以上代码的输出：

```js
0
-1
6
```

#### trim()

去除字符的头尾空格

#### forEach()

`forEach()` 方法用于调用数组的每个元素，并将元素传递给回调函数。

**注意:** `forEach()` 对于空数组是不会执行回调函数的。

**语法：**`array.forEach(function(currentValue, index, arr), thisValue)`

| 参数                                 | 描述                                                         |
| :----------------------------------- | :----------------------------------------------------------- |
| *function(currentValue, index, arr)* | 必需。 数组中每个元素需要调用的函数。 函数参数:参数描述*currentValue*必需。当前元素*index*可选。当前元素的索引值。*arr*可选。当前元素所属的数组对象。 |
| *thisValue*                          | 可选。传递给函数的值一般用 "this" 值。 如果这个参数为空， "undefined" 会传递给 "this" 值 |

#### Math.max()

返回多个数中的最大值

```js
Math.max(1, 2, 3) // 3
```

放在数组中，可以这样写

```js
let a = [1, 2, 3, 4]
Math.max(...a) // 4
Math.max.apply(null, a) // 4
```

#### Math.min()

返回多个数中的最小值

用法同上`Math.max()`

#### Math.pow(x,y)

幂计算：x的y次幂

#### Math.random()

返回一个**0 <= x < 1**的随机数

`Math.random() * range`，range表示产生的随机数的范围，比如`Math.random() * 32`，生成的随机数在0到32以内。

#### Math.round(num)

返回一个四舍五入后最接近的整数。

#### Math.floor(num)

向下取整

#### Math.ceil(num)

向上取整

#### num.toFixed()

保留小数

#### concat()

`concat()`方法可以简单的将其理解为合并数组。基于当前数组中的所有项创建一个新数组。简单的说，`concat()`先给当前数组创建一个副本，然后将接收到的参数添加到这个副本（数组）的末尾，最后返回一个新的数组。来看个简单的示例：

```javascript
var arr = [`大漠`,'30','W3cplus'];
console.log(arr); // ["大漠", "30", "W3cplus"]
var arr2 = arr.concat('Blog','2014');
console.log(arr2); // ["大漠", "30", "W3cplus", "Blog", "2014"]
```

上面代码演示的`concat()`方法传递的值不是数组，这些值就会简单添加到结果数组(`arr2`)的末尾。

除此之外，`concat()`传递的值还有其他的使用方法：同时传递一个或多个数组，如下所示：

```javascript
var arr = ["大漠","30"];
console.log(arr); // ["大漠", "30"]
var arr2 = arr.concat(1,["blog","w3cplus"],["a","b","c"]);
console.log(arr2); // ["大漠", "30", 1, "blog", "w3cplus", "a", "b", "c"]
```

另外,`concat()`还可以传递空值（也就是说没有传递参数），此时它只是复制当前数组，并且返回一个副本。如下所示：

```javascript
var arr = [1,2];
console.log(arr); // [1, 2]
var arr2 = arr.concat();
console.log(arr2); // [1, 2]
```

从上面几个示例，不难看出：`concat()`方法是在数组的副本上进行操作并返回新构建的数组，所以并不会影响到原来的数组。

#### 生命周期钩子函数

https://segmentfault.com/a/1190000008010666

##### beforeCreate()

在实例**初始化之后**，数据观测 (data observer) 和 event/watcher 事件**配置之前**被调用。

##### created()

在实例创建完成后被**立即调用**。在这一步，实例已完成以下的配置：数据观测 (data observer)，property 和方法的运算，watch/event 事件回调。然而，挂载阶段**还没开始**，`$el` property 目前尚不可用。

##### beforeMount()

在挂载**开始之前**被调用：相关的 `render` 函数首次被调用。

**该钩子在服务器端渲染期间不被调用。**

##### mounted()

实例被**挂载后**调用，这时 `el` 被新创建的 `vm.$el` 替换了。如果根实例挂载到了一个文档内的元素上，当 `mounted` 被调用时 `vm.$el` 也在文档内。

注意 `mounted` **不会**保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 `mounted` 内部使用 [vm.$nextTick](https://cn.vuejs.org/v2/api/#vm-nextTick)：

```javascript
mounted: function () {
  this.$nextTick(function () {
    // Code that will run only after the
    // entire view has been rendered
  })
}
```

**该钩子在服务器端渲染期间不被调用。**

##### beforeUpdate()

数据**更新时**调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。

**该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。**

##### updated()

由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。

当这个钩子被调用时，组件 DOM **已经更新**，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用[计算属性](https://cn.vuejs.org/v2/api/#computed)或 [watcher](https://cn.vuejs.org/v2/api/#watch) 取而代之。

注意 `updated` **不会**保证所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以在 `updated` 里使用 [vm.$nextTick](https://cn.vuejs.org/v2/api/#vm-nextTick)：

```
updated: function () {
  this.$nextTick(function () {
    // Code that will run only after the
    // entire view has been re-rendered
  })
}
```

**该钩子在服务器端渲染期间不被调用。**

##### activated()

被 keep-alive 缓存的组件**激活时**调用。

**该钩子在服务器端渲染期间不被调用。**

##### deactivated()

被 keep-alive 缓存的组件**停用时**调用。

**该钩子在服务器端渲染期间不被调用。**

##### beforeDestory()

实例**销毁之前**调用。在这一步，实例仍然完全可用。

**该钩子在服务器端渲染期间不被调用。**

##### destoryed()

实例**销毁后**调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。

**该钩子在服务器端渲染期间不被调用。**

#### 箭头函数=>

可用于匿名函数，但箭头函数没有`this`，因此**不能**在选项*property*上使用**箭头函数**。比如：

```javascript
created: () => console.log(this.a) 
```

或

```javascript
 vm.$watch('a', newValue => this.myMethod())
```

因为箭头函数并没有 `this`，`this` 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 
`Uncaught TypeError: Cannot read property of undefined` 或 `Uncaught TypeError: this.myMethod is not a function` 之类的错误。

https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions、

**基础语法**

```javascript
(param1, param2, …, paramN) => { statements } 
(param1, param2, …, paramN) => expression
//相当于：(param1, param2, …, paramN) =>{ return expression; }

// 当只有一个参数时，圆括号是可选的：
(singleParam) => { statements }
singleParam => { statements }

// 没有参数的函数应该写成一对圆括号。
() => { statements }
```

**高级语法**

```javascript
//加括号的函数体返回对象字面量表达式：
params => ({foo: bar})

//支持剩余参数和默认参数
(param1, param2, ...rest) => { statements }
(param1 = defaultValue1, param2, …, paramN = defaultValueN) => { 
statements }

//同样支持参数列表解构
let f = ([a, b] = [1, 2], {x: c} = {x: a + b}) => a + b + c;
f();  // 6
```

**箭头函数与function定义函数的写法：**

```js
//function
function fn(a, b){
	return a + b;
}
//arrow function
var foo = (a, b)=>{ return a + b };
123456
```

**this的指向：**

使用**function**定义的函数，`this`的指向是随着**调用环境**的变化而**变化的**，而**箭头函数**中的`this`指向是**固定不变的**，一直指向的是定义函数的环境。

```js
//使用function定义的函数
function foo(){
	console.log(this);
}
var obj = { aa: foo };
foo(); //Window
obj.aa() //obj { aa: foo }
1234567
```

> 使用function定义的函数中this指向是随着调用环境的变化而变化的

```js
//使用箭头函数定义函数
var foo = () => { console.log(this) };
var obj = { aa:foo };
foo(); //Window
obj.aa(); //Window
12345
```

> 明显使用箭头函数的时候，this的指向是没有发生变化的。

2021.04.09更新：**this指向问题的补充，箭头函数和普通函数写法的区别**

看下面一段代码：

```js
var name = 'zhangsan',
a = {
  name: 'lisi',
  func: function() {
    return this.name
  }
},
b = {
  name: 'lisi',
  func: function() {
    var a = {
      name: 'wnagwu',
      func: function() {
        return this.name
      }
    }
    return a.func()
  }
},
c = {
  name: 'lisi',
  func: function() {
    var a = {
      name: this.name,
      func: function() {
        return this.name
      }
    }
    return a.func()
  }
},
d = {
  name: 'lisi',
  func: function() {
    var a = {
      name: 'wangwu',
      func: () => {
        return this.name
      }
    }
    return a.func()
  }
},
e = {
  name: 'lisi',
  func: () => {
    var a = {
      name: 'wangwu',
      func: () => {
        return this.name
      }
    }
    return a.func()
  }
}
console.log(a.func()) // lisi
console.log(b.func()) // wangwu
console.log(c.func()) // lisi
console.log(d.func()) // lisi
console.log(e.func()) // zhangsan
```

通俗来说，箭头函数的`this`指向可以理解为：让`this`一直向上获取执行上下文，直到不能再向上获取为止。例如`对象d`，里边的箭头函数的`this`向上寻找执行上下文，碰到`对象a`的时候，因为`对象a`还可以继续追溯，所以`this`指针**越过了**`对象a`，来到`d.func()`。在这里，它碰到的是普通函数的定义写法，普通匿名函数的定义写法**不允许其继续向上寻找上下文**，因此`this`指针停在了`d.func()`，而这里`this`的值是`{name: "lisi", func: ƒ}`，所以打印`lisi`。当外层函数不再是普通函数定义写法，改为了箭头函数时，如同`对象e`的`func()`，里层的`this`追溯到这里时，可以继续向上寻找，**越过了**`对象e`，最终指向**window对象**，而`window`对象的`name`在最开始定义为`zhangsan`。

**注：`vue`的绑定方法，即`methods`中，this指向的是当前vue组件**

```js
methods: {
    thisTowards() {
		console.log(this) // VueComponent {_uid: 292, _isVue: true, $options: {…}, _renderProxy: Proxy, _self: VueComponent, …}
    }
}
```

#### split()

```javascript
stringObject.split(separator,howmany)
```

| **参数**  | **描述**                                                     | **解释**                                  |
| --------- | ------------------------------------------------------------ | ----------------------------------------- |
| separator | 必需。字符串或正则表达式，从该参数指定的地方分割 stringObject。 | 每遇到一个定义的separator，就分割字符串。 |
| howmany   | 可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。 |                                           |

#### join()

```javascript
arrayObject.join(separator)
```

| **参数**  | **描述**                                                     |
| --------- | ------------------------------------------------------------ |
| separator | 可选。指定要使用的分隔符。如果省略该参数，则使用逗号作为分隔符。 |

### 组件

#### 组件递归

在组件中定义`name`属性即可在组件中使用组件

组件：

```vue
<!-- component_demo.vue -->
<template>
	...
	<component-demo /> <!-- 与name一致 -->
	...
</template>

<script>
	export default {
        name: 'component-demo',
        ...
    }
</script>
```

#### QRCode.js

https://github.com/davidshimjs/qrcodejs

**安装**

`npm install qrcodejs2 -S`

**引入**

`import QRCode from 'qrcodejs2'   //不需要注册组件`

**基本应用**

```html
<div id="qrcode"></div>
<script type="text/javascript">
new QRCode(document.getElementById("qrcode"), "http://jindo.dev.naver.com/collie");
</script>
```

**创建并设置**

```javascript
var qrcode = new QRCode("test", {
    text: "http://jindo.dev.naver.com/collie",
    width: 128,
    height: 128,
    colorDark : "#000000",
    colorLight : "#ffffff",
    correctLevel : QRCode.CorrectLevel.H
});
```

**可调用方法**

```javascript
qrcode.clear(); // clear the code.
qrcode.makeCode("http://naver.com"); // make another code.
```



### 标签

#### svg

https://www.cnblogs.com/luoxuemei/p/12154835.html

下载下来svg后，要在svg文件中将`fill`属性填充的颜色去掉，才可以用`hover`改变颜色。`cursor: pointer;`使鼠标移动上去时变成手。



#### ref和$refs

有时需要在JavaScript里直接访问一个子组件。为了达到这个目的，通过`ref`这个attribute为子组件赋予一个ID引用。例如：

`<base-input ref="usernameInput"></base-input>`

现在在已经定义了这个`ref`的组件里，可以使用：

`this.$refs.usernameInput`

来访问这个<base-input>实例。 

#### v-if

在`div`中使用`v-if`，`v-else`，`v-else-if`语句，可以对`div`进行选择性展示。语句后内容是条件代码。

#### v-for

`v-for` 指令需要以 `site in sites` 形式的特殊语法， `sites` 是源数据数组并且 `site` 是数组元素迭代的别名。

`v-for`内要搭配`v-bind:key=" "`

**为什么要添加key？**

如果没有`key`，虚拟`dom`在更新节点树的时候是层层逐个遍历，效率很低，特别是对`v-for`的元素进行插入时，没有`key`作唯一标识，会出现插入后标记错误。

`key`对每一个节点作一个唯一标识，`Diff`算法就可以正确识别此节点，找到正确的位置插入新节点；`vue`组件高度复用，添加`key`为了高效地更新虚拟`dom`。

#### v-bind和v-model

它们都是绑定Vue中`data`的属性的，主要区别是`v-bind`绑定的是单向的数据，它将`data`中的数据投影到绑定的地方，在被绑定的地方修改数据是不会影响data中的原始数据的，而`v-model`是双向的，改变标签中的数据或`data`中的数据都会影响到对方。

#### v-on

https://cn.vuejs.org/v2/api/?#v-on

- `.stop `- 调用 `event.stopPropagation()`。
- `.prevent `- 调用 `event.preventDefault()`。
- `.capture `- 添加事件侦听器时使用 capture 模式。
- `.self `- 只当事件是从侦听器绑定的元素本身触发时才触发回调。
- `.{keyCode | keyAlias} `- 只当事件是从特定键触发时才触发回调。
- `.native `- 监听组件根元素的原生事件。
- `.once `- 只触发一次回调。
- `.left `- (2.2.0) 只当点击鼠标左键时触发。
- `.right `- (2.2.0) 只当点击鼠标右键时触发。
- `.middle `- (2.2.0) 只当点击鼠标中键时触发。
- `.passive `- (2.3.0) 以 `{ passive: true }` 模式添加侦听器

#### v-slot

**具名插槽**

有时候我们希望在指定的位置输出我们的子元素，这时候具名插槽就排上了用场。

```vue
//组件调用时
<MyFooter v-red :age.sync="age">
  <template v-slot:footer>
  //这里v-slot：后边的值与组件内的slot的name属性对应，也就是插槽的名称。
      <div>list</div>
  </template>
</MyFooter>
//书写组件时
<template>
    <div>
        {{age}}
        <div>
            <slot name='footer' />
            //这里name的值就是这个插槽的名称。
        </div>
    </div>
</template>
```

**作用域插槽**

作用域插槽的主要作用是在书写插槽内容时可以获取到插槽作用域的值。

```vue
//组件调用
 <ul>
   <myli :title="val.title"
   >
   <template v-slot:footer="message">
       <div>{{message.aa}}</div>
   </template>
   </myli>
 </ul>
 //书写组件时
 <template>
    <li>
        <slot name='footer' :aa="title">
        </slot>
    </li>
</template>
```

**注意事项：**
这里需要注意的是`message`是所有你绑定属性的集合，也就是你写的：`aa=“title”`会当做`message`的属性来实现。当然这里`message`可以换做其它的名称。

**总结**

`v-slot`的出现是为了代替原有的`slot`和`slot-scope`
简化了一些复杂的语法。
一句话概括就是`v-slot` ：后边是插槽名称，=后边是组件内部绑定作用域值的映射。



需要多个插槽时，可以利用<slot>元素的一个特殊的特性：`name`来定义具名插槽。例如：

<base-layout>子组件模板定义：

```html
<div class="container">
  <header>
    <slot name="header"></slot>
  </header>
  <main>
    <slot></slot>
  </main>
  <footer>
    <slot name="footer"></slot>
  </footer>
</div>
```

父组件使用子组件<base-layout>，节点上使用slot特性：

```html
<base-layout>
  <h1 slot="header">Here might be a page title</h1>
 
  <p>A paragraph for the main content.</p>
  <p>And another one.</p>
 
  <p slot="footer">Here's some contact info</p>
</base-layout>
```

也可以在内容外套一个节点，并在外层节点上使用slot特性：

```html
<base-layout>
  <template slot="header">
    <h1>Here might be a page title</h1>
  </template>
 
  <p>A paragraph for the main content.</p>
  <p>And another one.</p>
 
  <template slot="footer">
    <p>Here's some contact info</p>
  </template>
</base-layout>
```

渲染出来的html都将会是：

```html
<div class="container">
  <header>
    <h1>Here might be a page title</h1>
  </header>
  <main>
    <p>A paragraph for the main content.</p>
    <p>And another one.</p>
  </main>
  <footer>
    <p>Here's some contact info</p>
  </footer>
</div>
```

## Angular

### 指令

#### [ngstyle]

#### ng-repeat

**ng-repeat** 指令用于循环输出**指定次数**的 HTML 元素。集合必须是**数组**或**对象**。

**数组：**

```js
arr = [
	'我是1',
	'我是2',
	'我是3'
]

// html
<p ng-repeat="(x, y) in arr">
    {{ x + y }}
</p>

// 展示结果
0我是1
1我是2
2我是3
```

**对象：**

```js
obj = {
	one: '我是1',
	two: '我是2',
	three: '我是3'
}

// html
<p ng-repeat="(x, y) in obj">
    {{ x + y }}
</p>

// 展示结果
one我是1
two我是2
three我是3
```

#### ng-csv导出为表格.csv文件

**表格示例：**

| 学号 | 姓名 | 班级  |
| ---- | ---- | ----- |
| 101  | 张三 | 初一1 |
| 102  | 李四 | 初一2 |

**代码：**

```html
<button
	ng-csv-down
	ng-csv-name="fileToCsv.name"
	ng-csv-data="fileToCsv.data"
	ng-csv-fields="fileToCsv.fields"
>导出表格</button>
```

```js
// 定义表属性
$scope.fileToCsv = {
    name: '学生信息表.csv', // 文件名称
    data: [], // 表格数据
    fields: ['学号', '姓名', '班级'] // 表头
}

// 插入数据
$scope.fileToCsv.data.push(
	{
        '学号': '101',
        '姓名': '张三',
        '班级': '初一1'
    },
    {
        '学号': '102',
        '姓名': '李四',
        '班级': '初一2'
    }
)
```

拥有**多级目录**的表格如何设置数据格式？

**表头示例：**

|          | 第一周   |          |          | 第二周   |          |
| -------- | -------- | -------- | -------- | -------- | -------- |
| 教师名称 | 上课班级 | 课程类型 | 教师名称 | 上课班级 | 课程类型 |

这里需要把第一行作为**真正的表头**，二级表头当做**第一条数据**。

**代码（设置空表头需要使用空格，不能使用空字符串）：**

```js
// 定义表属性
$scope.fileToCsv = {
    name: '学生信息表.csv', // 文件名称
    data: [ // 表格数据，插入第一条数据，作为二级表头
        {
        ' ': '教师名称',
        '第一周': '上课班级',
        ' ': '课程类型',
        ' ': '教师名称',
        '第二周': '上课班级',
        ' ': '课程类型'
    	}
    ],
    fields: [ // 表头，设置空表头需要使用空格，不能使用空字符串
        ' ',
        '第一周',
        ' ',
        ' ',
        '第二周'
        ' '
     ]
}
```

这里会有一个问题，就是在插入数据时，是以对象格式插入数据，当表头**设置为空字符串**时，若**字符串长度都一样**，会导致**数据被覆盖**的问题（对象相同属性赋值）。

所以，解决方法是将空字符串的**空格数递增**，以达到没有相同属性值的效果，如下。

```js
// 定义表属性
$scope.fileToCsv = {
    name: '学生信息表.csv', // 文件名称
    data: [ // 表格数据，插入第一条数据，作为二级表头
        {
        ' ': '教师名称', // 1个空格
        '第一周': '上课班级',
        '  ': '课程类型', // 2个空格
        '   ': '教师名称', // 3个空格
        '第二周': '上课班级',
        '    ': '课程类型' // 4个空格
    	}
    ],
    fields: [ // 表头，设置空表头需要使用空格，不能使用空字符串
        ' ', // 1个空格
        '第一周',
        '  ', // 2个空格
        '   ', // 3个空格
        '第二周'
        '    ' // 4个空格
     ]
}
```

#### ng-options

ng-options指令用于使用数组元素填充下拉列表。

最常见的用法是使用**数组**填充：

```html
<select ng-model="selectedName" ng-options="item.name for item in items">
 $scope.items= ["Emil","Tobias","Linus"];
</select>
```

此时的item作为`$scope.selectedName`的值

当数组中每一项都是**对象**时：

```html
<select ng-model="selectedName" ng-options="item.name as item.name for item in items">
 $scope.items = [{name:"Emil",age:"12"},
                    {name:"Tobias",age:"13"},
                    {name:"Linus",age:"14"}];
</select>
```

此时使用item.name as（可选） 将item.name作为$scope.selectedName ，item.name for将name 的值设置为options下拉中的可见选项。
那如果我下拉选项中想显示多个信息呢？例如将name和age显示为“Emil（12）” 的格式呢？可以使用如下办法：

```html
<select ng-model="selectedName" ng-options="item.name as item.name+' (' + item.age + ')' for item in items">
</select>
 $scope.items = [{name:"Emil",age:"12"},
                    {name:"Tobias",age:"13"},
                    {name:"Linus",age:"14"}];
</select>
```

当然啦，我们也可以用来遍历对象

```html
<select ng-model="selectedName" ng-options="x for (x,y) in items">
</select>
 $scope.items = {Emil:"12",Tobias:"13",Linus:"14"}         
</select>
```

**解决选项第一个为空的问题**

用`ng-options`生成的选项，默认第一个为空，影响体验。添加以下代码去除。

```html
<select ng-model="selectedName" ng-options="x for (x,y) in items">
</select>
 <option value="" selected hidden></option>
</select>
```

**将选项第一位置位默认值**

将`ng-model`绑定的值置为`options`第一位即可。

------

## 报错

### tab页切换时，echarts消失问题

场景：开发两个`tab`页面，两个页面都有`echarts`图，但是在切换tab时，一个页面的`echarts`切换正常，但另一个页面切换回来时`echarts`消失了。

代码说明：两个页面在生成`echarts`时都使用了`this.$refs`来获取`div`，区别在于切换正常的页面，是在接口返回之后调用`echarts`，而异常页面因为还在开发静态，没有调用接口。

根本原因：使用`this.$refs`来获取`div`需要在异步的情况下才能成功获取，否则会拿到`undefined`。而且这个`tab`页是通过`v-if`来控制的，也就是响应式。

详细说明：`this.$refs`不是响应式的功能，因此在`v-if`来回切换的时候，不显示的页面为`undefined`，`vue`获取不到`div`，因此也就无法更新画布。而正常的页面将更新画布的方法放在了接口中，给予了它一个异步的环境，因此切换正常；异常的页面使用的是静态数据，没有一个异步环境。要解决问题，就需要营造异步环境。

解决方法：

1. 将更新画布方法放入接口返回中调用。
2. `setTimeout`延迟。
3. 用`this.$nextTick()`。

### 项目过大，启动时内存溢出问题

报错：

```shell
FATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed - JavaScript heap out of memory
```

解决方法：

首先，安装插件

```
npm install -g increase-memory-limit
```

然后删除`node_moudles`文件夹，重新

```
npm install
```

之后执行

```
npx cross-env LIMIT=8192 increase-memory-limit
```

然后会遇上一个报错

![](https://img-blog.csdnimg.cn/20201126123253553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNjA4Mjgz,size_16,color_FFFFFF,t_70)

解决的办法是将`node_moudles/.bin`文件夹下的所有`.cmd`文件中的`"%_prog%"`双引号去掉，变为`%_prog%`。

这就要用到`VSCode`的全局替换功能了

右键`node_moudles/.bin`文件夹选择`在文件夹中查找`，在搜索栏中输入`"%_prog%"`，但是会发现找不到结果或者仅能找到一个结果，这是因为搜索功能默认不在`node_moudles`文件夹中搜索，我们在左下角点击设置-设置，在搜索栏中输入

```
@id:files.exclude,search.exclude,search.useGlobalIgnoreFiles,search.useIgnoreFiles
```

呼出搜索功能的设置项，然后在

```
Search: Exclude
配置glob模式以在全文本搜索和快速打开中排除文件和文件夹。从“＃files.exclude＃”设置继承所有glob模式。在此处了解更多关于glob模式的信息
**/node_modules
**/bower_components
**/*.code-search
```

删除`**/node_modules`项，即可搜索`node_moudles`文件夹，别忘了在替换完之后**恢复该项**，否则以后的搜索都会将`node_moudles`文件夹纳入搜索范围。

最后，将`"%_prog%"`替换为`%_prog%`，重新启动项目即可。

### 路由传参时参数丢失问题

路由传参时要尽量避免传对象类型的值，因为转换为网页url时会被解析为字符串`'Object'`，导致该对象内的属性丢失，尤其避免只传一个对象，对象中又包含多个值的情况。

例如：

```js
let anObject = {
    name: 'zhangsan',
    height: '173cm',
    weight: '65kg'
}
this.$router.push({
	path: '/detail',
    query: {
        anObject
    }
})
```

使用这种方式传递路由，会被解析成：

```
http://xxx.com:8051/detail?anObject=%5Bobject%20Object%5D
```

那么就无法通过网页url来访问该页面的内容，因为路由中无数据

**解决方法：**使用**扩展运算符**`...`将要穿的对象展开即可

```js
let anObject = {
    name: 'zhangsan',
    height: '173cm',
    weight: '65kg'
}
this.$router.push({
	path: '/detail',
    query: {
        ...anObject
    }
})
```

网页url会变成：

```
http://xxx.com:8051/detail?name=zhangsan&height=173cm&weight=65kg
```

即可通过`url`访问指定页面

### 使用参数解构时，获取到的参数显示undefined

**原因：**传参和形参的属性名称不一致，函数中找不到该属性因此报`undefined`。

```js
function test(name, {age, height}) {
    console.log(name, age, height)
}
test('zhangsan', { age: 10, gender: '男'}) // 'zhangsan' 10 undefined
test('zhangsan', { age: 10, height: '170cm'}) // 'zhangsan' 10 170cm
```

**解决方法：**传参属性名称保持一致。

### 在div中直接使用el-col时，el-col不展示高度属性

```vue
<div>
	<el-col>
    	content
    </el-col>
</div>
```

el-col中有内容，但div的高度显示为零。

**原因：**el-col是列设置，只会针对列方向进行定位，如比例，间隔等，有宽度而无高度。el-row才是行设置，才会有高度。

**解决方法：**在el-col外括一个el-row即可。

```vue
<div>
	<el-row>
    	<el-col>
    		content
    	</el-col>
    </el-row>
</div>
```

### 在公共表格组件点击事件回调报错Cannot read property 'toLowerCase' of undefined

**原因：**`click`方法需要的两个参数缺了一个。

**解决方法：**后来发现是传参时数据位置放错了。。。

### 调用百度地图报错TypeError: Cannot read property 'panTo' of null

某个需求中，需要在经纬度坐标改变时移动地图的中心。经纬度坐标是通过父组件传值`stationList`中的`longitude`和`latitude`获取，因此我将这两个值提取到一个对象中监听：

```js
computed: {
  listenLocation() {
    const { longitude, latitude } = this.stationList
    return { longitude, latitude }
  }
},
watch: {
  'listenLocation': function(val) {
    if (val.longitude && val.latitude) {
      this.map.panTo({ lng: val.longitude, lat: val.latitude })
    }
  }
}
```

但在地图初始化时，会报错`TypeError: Cannot read property 'panTo' of null`，猜测原因可能是初始化时`longitude`和`latitude`没有获取到值，百度了一下，`父组件通过props传值到子组件，而data是无法访问到props里面的值的，所以要用watch监听去获得`,所以我改了监听的写法：

```js
computed: {
  listenLocation() {
    const { longitude, latitude } = this.stationList
    return { longitude, latitude }
  }
},
watch: {
  'station.longitude': function(val) {
    if (val && this.station.latitude) {
      this.map.panTo({ lng: val, lat: this.station.latitude })
    }
  },
  'station.latitude': function(val) {
    if (val && this.station.longitude) {
      this.map.panTo({ lng: this.station.longitude, lat: val })
    }
  }
},
```

然后就不报错了。。。

### TypeError: 对象不支持此操作 v-on handler。IE下Element UI侧栏折叠，鼠标滑过时的报错

**原因：**在于element-ui的submenu代码中多处使用了`new MouseEvent('***')`，但是ie中不支持该种操作。

**解决方法：**修改源码（`node_modules\element-ui\lib\element-ui.common.js` ）加上一个如下[polyfill](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/MouseEvent)就好了。**在原来的代码末尾直接添加整段代码。**

```js
(function (window) {
  try {
    new MouseEvent('test');
    return false; // No need to polyfill
  } catch (e) {
		// Need to polyfill - fall through
  }

    // Polyfills DOM4 MouseEvent
	var MouseEventPolyfill = function (eventType, params) {
		params = params || { bubbles: false, cancelable: false };
		var mouseEvent = document.createEvent('MouseEvent');
		mouseEvent.initMouseEvent(eventType,
			params.bubbles,
			params.cancelable,
			window,
			0,
			params.screenX || 0,
			params.screenY || 0,
			params.clientX || 0,
			params.clientY || 0,
			params.ctrlKey || false,
			params.altKey || false,
			params.shiftKey || false,
			params.metaKey || false,
			params.button || 0,
			params.relatedTarget || null
		);

		return mouseEvent;
	}

	MouseEventPolyfill.prototype = Event.prototype;

	window.MouseEvent = MouseEventPolyfill;
})(window);
```

### 解决IE浏览器下重复的接口请求直接读取缓存的问题

**原因：**IE浏览器中，对重复的接口请求，是直接读取缓存里的内容，获取的数据也是上一个接口请求到的数据，对于一些需要实时刷新的数据，就会造成不刷新数据的问题。

**解决方法：**在接口`url`后面添加时间戳，这样每次请求的`url`都会不同。

```js
/**
 * get user base info
 */
export function getUserInfo() {
  return request({
    url: 'common/ajax/user/info.do' + '?t=' + Date.now(),
    method: 'get'
  })
}
```

### vue路由跳转路径成功，无报错但页面空白

**原因：**原本写的路由结构是三层，第一层是框架，第二层是页面分类，第三层才是具体页面。然而这三层路由的设置中，第一层的`component`是`layout`框架，第三层的`component`是引入的具体页面，第二层并没有设置`component`，因此路由在经过第二层时，找不到具体的展示效果，最终显示空白。

原代码：

```js
// 设备监控
{
  path: 'device', // 二级路由
  name: 'device',
  redirect: '/monitor/device/list',
  children: [
    // 设备列表
    {
      path: 'list', // 三级路由，具体页面
      name: 'device_list',
      component: () => import('@/components/views/monitor/device/device_list.vue')
    },
    // 设备详情
    {
      path: 'detail', // 三级路由，具体页面
      name: 'device_detail',
      component: () => import('@/components/views/monitor/device/device_detail.vue')
    }
  ]
}
```

正确写法：去掉二级路由，将二级路由路径加入到三级路由路径中

```js
// 设备列表
{
  path: 'device/list', // 将二级路由路径加入到三级路由路径中
  name: 'device_list',
  component: () => import('@/components/views/monitor/device/device_list.vue')
},
// 设备详情
{
  path: 'device/detail', // 将二级路由路径加入到三级路由路径中
  name: 'device_detail',
  component: () => import('@/components/views/monitor/device/device_detail.vue')
}
```

### IE浏览器报错vuex requires a Promise polyfill in this browser.

**原因：**因为使用了ES6 Promise,而IE浏览器不支持

**解决方法：**

1. 使用`babel-polyfill`

   ```shell
   npm install --save-dev babel-polyfill 
   ```

2. 在`webpack.base.conf.js`中设置

   ```js
   module.exports = {
     entry: {
       app: ['babel-polyfill', './src/main.js'] // 添加这一行
       // app: './src/main.js' // 这行注释掉
     },
   ```

### el-select-dropdown底部显示不全

https://www.itben.cn/archives/34/

**原因：**控制其他样式时设置了

```scss
overflow-x: hidden;
```

如此一来原本底部导航条的位置就消失了。

**解决方法：**针对select组件样式进行了如下填补

```css
.el-select-dropdown .el-scrollbar .el-scrollbar__wrap
{
    overflow: scroll !important;
}
```

填补的样式一定要加`!important`，以及不能写在标记了`scoped`的`style`域内。

### 用js写了一个数据结构，引入到其他文件时，直接使用import的内容会报错：Property or method "menu" is not defined on the instance but referenced during render.

**原因：**引入的内容并非响应式的，没有在内部定义但直接在页面中使用了。也就是说光`import`就直接在<template>中使用是不够的，还需要在<script>中将该引入注册为响应式。

**解决方法：**数据结构可在**data**中新建一个变量，将引入赋值给该变量，使其变为**响应式**。引入组件则需要在`components`中注册。

```js
import menu from './menu.js'
...
data() {
	return{
		newMenu: menu
	}
}
```

### 路由路径一样，参数不一样时，页面不会跳转

在某些情况下，在同一个路径下参数改变时路由不会执行push。

**解决方法：**push之后，location.reload()刷新页面。

### echarts在el-tab中切换时缩在一起

`echarts`无法正确继承`width:100%;`，从而只得到默认宽度`100px`

**原因：**tab选项卡切换到含有echarts页面之前，echarts页面的display属性为none，所以echarts的继承宽度width: 100%;找不到父级参数，只能给个默认值100px，因此切换时会看到echarts图表缩在了一起。

**解决方法：**

- 保证tabs比echarts先渲染，这样echarts就能获取到父级宽度继承。

  ```vue
  <!-- template -->
  <el-tabs v-model="activeName" @tab-click="handleClick">
  	<el-tab-pane name="echarts">
  		<div class="chart-wrapper">
  			<echarts v-if="isChartNeed" />
  		</div>
  	</el-tab-pane>
  </el-tabs>
  ```

  ```js
  // tabs切换操作
  handleClick(tab, event) {
  	if (tab.name === 'echarts') {
          this.isChartNeed = true
      }
  }
  ```

- 监听tab点击事件，执行reload方法，但是这种方式消耗性能。

### this指向问题

开发过程中有可能会遇到this后面的函数/值找不到的问题

**原因：**可能是`this`在使用时被其他方法影响，造成`this`指向改变

例如：在一个*Vue*实例方法中控制台输出`this`

```js
function fnThis(){
	console.log(this)
}
fnThis() // 会输出Window {window: Window, self: Window, document: document, name: "", location: Location, …}
```

会输出窗口对象`Window`，但是若将该方法作为某个对象的属性时，该方法中的`this`将不再指向当前窗口，而是被改变为指向引用该方法的对象。

```js
// 接上
var obj = {
    fn: fnThis // 将上面的方法fnThis()作为obj对象的fn属性的值
}
// 此时再调用对象中的fnThis方法
obj.fn() // 会输出{aa: ƒ}，ƒ代表一个方法
```

此时this指向发生了变化，若要保证this指向不发生变化，可使用两种方法：

1. 将this指向先保存在某个变量里

   ```js
   var that = this // 将this保存在that变量中
   function fnThis(){
   	console.log(that) // 用that替换this
   }
   var obj = {
       fn: fnThis // 将上面的方法fnThis()作为obj对象的fn属性的值
   }
   // 此时再调用对象中的fnThis方法
   obj.fn() // 会输出Window {window: Window, self: Window, document: document, name: "", location: Location, …}
   ```

   对比可以发现，this的指向被保存下来之后不会被影响。

2. 使用箭头函数

   > 详见：Vue-函数-箭头函数

完整的js代码（Vue实现）：

```js
var app = new Vue({
				el: '#app',
				mounted() {
					this.start()
				},
				methods: {
					start() {
						var that = this
						function fnThis() {
							console.log('fnThis: ', this)
						}
						var arrowThis = () => {
							console.log('arrowThis: ', this)
						}
						var obj = {fn: fnThis, arrow:arrowThis}
						fnThis()
						arrowThis()
						obj.fn()
						obj.arrow()
					}
				}
			});
```

### Cannot read property '_t' of null

使用了国际化语言插件i18n，在页面快速跳转时概率性报错

**原因：**vue项目中页面路由快速跳转时，vue-18n有一定概率报错Cannot read property '_t' of null。
来回跳转的多个页面都有配置多语言，如html里的`{{$t("xxx.xxx")}}`，`data`或`method`里的`vue.$t('xxx.xxx')`或者`this.$t('xxx.xxx')`。
在第一页面跳转第二时，页面1的多语言还没加载完成但已经跳转到页面2了，就找不到页面1里的this指向了。

**解决方法：**配置多语言的单页面里**单独引入**`i18n`,代码如下：
页面里 的`this.$t('xxx.xxx')`或者`vue.$t("xxx.xxx")` 改成 `i18n.t('xxx')`,注意修改后**不在需要$**符号!!!

```js
import i18n from '@/lang'
```

### el-table筛选功能，取不到column的信息

`el-table`可以触发筛选方法，但是`column`的传参无法获取到具体信息

**原因：**`el-table-column`属性中缺少了`prop`属性，使得`filter`分不清触发的是哪一列的筛选。

**解决方法：**el-table-column属性中添加`prop`属性。

### xxx.filter is not a function

**原因：**`filter`只支持**数组**过滤。

**解决方法：**将搜索对象和目标改为数组形式。

### 有多个v-if时，v-else无法生效

**原因：**当只有`v-if`和`v-else`时，`v-else`只对紧挨的`v-if`生效。

**解决方法：**若没有`v-else`，则可以使用多个`v-if`来进行筛选；若需要用到`v-else`时，`v-else`只会对最近的`v-if`产生`if-else`关联。此时，将第一个`v-if`之后的`v-if`改为`v-else-if`即可。

### Duplicate keys detected: '0'. This may cause an update error.

**原因：**一个`template`中有两个**一样的v-for**

**解决方法：**将其中一个的**key**修改一下

**注意：**这里的修改`key`不能只是单纯的改名字，要添加字符串才算真正改名。

```vue
// 无效改名
:key="index" /*改为*/ ：key="id"
// 有效改名
:key="index" /*改为*/ :key="'another' + index"
```

### 对“最后一项”的样式修改无效

应该特别注意“最后一项”选择器出现的**位置顺序**，特别是当样式名称有多个字段时，注意选取到正确的位置。详见项目搭建-细节配置-样式中对“最后一项”的设置。

### vue输入框报错Invalid prop: type check failed for prop "clearable".

**原因：**`el-input`中使用了可清除属性`clearable`，但是却给这个属性赋了错误的值

```html
<el-input clearable="true" />
```

**解决方法：**不需要赋值，或者使用正确的方法用变量赋值。

```html
<el-input clearable />
<!-- 或者 -->
<el-input :clearable="true" />
<!-- 或者 -->
<el-input :clearable="input_isclearable" />
```

### vue中<style>类型为scss时使用深度选择器`/deep/`报错Expected selector

找到vue官网关于深度选择器是这样说的：

有些像 **Sass** 之类的预处理器无法正确解析 `>>>`。这种情况下你可以使用 `/deep/` 或 `::v-deep` 操作符取而代之——两者都是 `>>>` 的别名，同样可以正常工作。

于是用 `::v-deep` 就可以了，注意使用`::v-deep` 时后面要**带空格**。

### echarts中，this指向无法正确获取，显示undefined的问题

**原因：**暂不清楚

**解决方法：**可以在外部先将this保存下来，再使用保存后的变量。

```js
that = this
function() {
	that.something
}
```

或者在报错的地方将`function`改为箭头函数

```js
color: function(param) {
    something...
}
// 改为
color: param => {
    something...
}
```



### 跳转页面时，前页面的样式发生改变/错位，跳转回去后依旧错位，但刷新页面又恢复正常

**可能原因：**

1. 样式未加`scoped`，在vue中，不加`scoped`的样式有可能导致样式复用。
2. 组件本身的问题：例如，在一个`el-button`中又镶嵌了一个`el-button`，那么页面跳转时将必然会发生错位现象。

**解决方法：**

1. 在<style>中加入`scoped`，变为<style scoped>。但是会导致当前页面对于Element UI的样式修改失效，可采用两种解决方案：一是在全局样式中修改Element UI样式，缺点是这样修改无法针对独个页面；二是使用深度选择器`>>>`添加在当前页面的样式代码中，即可对Element UI样式进行修改。
   例如：

   ```css
   <style scoped>
   >>>.el-button--mini.is-circle {
     margin: 0;
     width: 24px;
     height: 24px;
     padding: 0;
   }
   </style>
   ```

2. 替换组件，使用其他不会引起冲突的组件来展示。

### el-menu使用中，点击某个子菜单，所有的菜单都有相应动作

**原因：**`el-menu-item`没有设置`index`，则所有item默认为空，即所有item值都相等，所以对某个单独的item操作，所有的item都会反应。

**解决方法：**给`el-menu-item`添加唯一`index`属性即可。

### v-for和v-if不能同时使用

https://blog.csdn.net/namechenfl/article/details/83987488

**原因：**v-for和v-if同时存在时，v-for的优先级高于v-if，相当于每次循环都执行了一次判断。

**解决方法：**将循环的对象放入计算属性中，通过`filter()`函数过滤，代替`if`判断，然后返回对象。

```js
computed: {
activeUsers: function () {
return this.users.filter(function (user) {
return user.isActive
})
}
}
```

```vue

<ul>
<li
v-for="user in activeUsers"
:key="user.id"
>
{{ user.name }}
</li>
</ul>
```

### 用户名存入store中后刷新页面数据丢失

页面刷新后，vue实例重新加载，从而store也被重置，store是用来存储组件状态的，而不是用来做本地数据存储的。所以，对于不希望页面刷新之后被重置的数据，使用本地存储来进行存储。

**cookie:** 不适合存储大量的数据。

**localStorage:** 是永久存储，浏览器关闭后数据不会丢失，除非主动删除数据。当关闭页面后重新打开，会读取上一次打开的页面数据。

**sessionStorage:** 在当前浏览器窗口关闭后自动删除。所以，sessionStorage 最合适。

### 引入了Element UI的自定义主题后启动报错

**原因：**在引入时，将theme文件夹和config.json一同放入工程跟目录下。

**解决方法：**删除config.json文件（或引入主题时只引入theme文件夹即可）

### 新建项目安装vuex报错rename

清除npm缓存：

```npm
npm cache clean --force
```

然后重新运行安装命令

### Vue语法检测报错：warning  Prop "LogLineCharts" is not in camelCase

**解决方法：**prop "LogLineCharts" 没有使用驼峰体命名规范，将首字母改为**小写**即可。

### 向子组件传数据时，子组件可以获取到数据，但是对该数据进行操作时返回空数组。

父组件请求数据**需要时间**且父组件向子组件**实时传递**数据。初始化时父组件的数据为空，传给子组件的数据也为空。但子组件对父组件传过来的数据进行操作是对第一次传的数据操作，即空数据。

**解决方法：**

1. 初始化时父组件使用局部变量替换，不要直接对要传递的数据进行操作。
2. 子组件可以加定时器，等待父组件传递过来的数据不为空时再操作。

### 使用this.$refs[formName].validate作表单验证时无法执行里面的内容

https://segmentfault.com/q/1010000009679079

首先打印一下this.$refs[formName]，检查是否拿到了正确的需要验证的form。
其次在拿到了正确的form后，检查该form上添加的表单验证是否正确，需要注意的点有：

1. el-form rules，**model属性绑定**（是**：model**而不是**v-model**），ref标识
2. el-form-item prop属性绑定

### 二维码刷新时图案闪烁

在装二维码的容器中设定宽高与二维码大小一致即可。

```html
      <div id="qrcode" ref="qrcode" style="margin-left: 33px; width: 200px; height: 200px;" />
```

### 使用`el-table`时列内容过多不显示或放大缩小导致排版空白错位等问题

在`el-table-column`标签中添加属性：**min-width**，其值为该列所占的最小宽度。设置后放大屏幕时列宽会保持在最小宽度以上；缩小屏幕时各列的宽度会自动适应。

### Element UI无法绑定点击事件

在`@click`后加`.native`变成`@click.native="方法名"`即可。

### Duplicate keys detected: '990510e006100'. This may cause an update error.

**解决方法：**

```javascript
<div v-for="alarmObject in currentAlarm.alarmData" :key="alarmObject.deviceName" :data="currentAlarm.alarmData">
```

**改为：**

```javascript
<div v-for="(alarmObject,index) in currentAlarm.alarmData" :key="index" :data="currentAlarm.alarmData">
```

### 项目导入启动报错

![image-20200804230928851](C:\Users\82317\AppData\Roaming\Typora\typora-user-images\image-20200804230928851.png)

------

## Vuex

https://scrimba.com/g/gvuex

Vuex 是一个专为 Vue.js 应用程序开发的**状态管理模式**。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 [devtools extension](https://github.com/vuejs/vue-devtools)，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。

### 开始

Vuex 和单纯的全局对象有以下两点不同：

1. Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。
2. 你不能直接改变 store 中的状态。改变 store 中的状态的**唯一途径**就是显式地**提交 (commit) mutation**。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。

**创建**

```js
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

const store = new Vuex.Store({
  state: {
    count: 0
  },
  mutations: {
    increment (state) {
      state.count++
    }
  }
})
```

现在，你可以通过 `store.state` 来获取状态对象，以及通过 `store.commit` 方法触发状态变更：

```js
store.commit('increment')

console.log(store.state.count) // -> 1
```

为了在 Vue 组件中访问 `this.$store` property，你需要为 Vue 实例提供创建好的 store。Vuex 提供了一个从根组件向所有子组件，以 `store` 选项的方式“注入”该 store 的机制：

```js
new Vue({
  el: '#app',
  store: store,
})
```

现在我们可以从组件的方法提交一个变更：

```js
methods: {
  increment() {
    this.$store.commit('increment')
    console.log(this.$store.state.count)
  }
}
```

### 核心概念

#### state

**单一状态树**

Vuex 使用**单一状态树**——是的，用一个对象就包含了全部的应用层级状态。至此它便作为一个“唯一数据源 ([SSOT](https://en.wikipedia.org/wiki/Single_source_of_truth))”而存在。这也意味着，每个应用将**仅仅包含一个 store** 实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。

单状态树和模块化并不冲突——在后面的章节里我们会讨论如何将状态和状态变更事件分布到各个子模块中。

存储在 Vuex 中的数据和 Vue 实例中的 `data` 遵循相同的规则，例如状态对象必须是纯粹 (plain) 的。**参考：**[Vue#data](https://cn.vuejs.org/v2/api/#data)。

**在 Vue 组件中获得 Vuex 状态**

那么我们如何在 Vue 组件中展示状态呢？由于 Vuex 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是在[计算属性](https://cn.vuejs.org/guide/computed.html)中返回某个状态：

```js
// 创建一个 Counter 组件
const Counter = {
  template: `<div>{{ count }}</div>`,
  computed: {
    count () {
      return store.state.count
    }
  }
}
```

每当 `store.state.count` 变化的时候, 都会重新求取计算属性，并且触发更新相关联的 DOM。

然而，这种模式导致组件依赖全局状态单例。在模块化的构建系统中，在每个需要使用 state 的组件中需要频繁地导入，并且在测试组件时需要模拟状态。

Vuex 通过 `store` 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 `Vue.use(Vuex)`）：

```js
const app = new Vue({
  el: '#app',
  // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件
  store,
  components: { Counter },
  template: `
    <div class="app">
      <counter></counter>
    </div>
  `
})
```

通过在根实例中注册 `store` 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 `this.$store` 访问到。让我们更新下 `Counter` 的实现：

```js
const Counter = {
  template: `<div>{{ count }}</div>`,
  computed: {
    count () {
      return this.$store.state.count
    }
  }
}
```

### 其他

#### vuex中store存储store.commit和store.dispatch的区别及用法

**代码示例：**

```js
this.$store.commit('loginStatus', 1);

this.$store.dispatch('isLogin', true);
```

规范的使用方式：

```js
// 以载荷形式
store.commit('increment'，{
  amount: 10   //这是额外的参数
})

// 或者使用对象风格的提交方式
store.commit({
  type: 'increment',
  amount: 10   //这是额外的参数
})
```

**主要区别：**

- **dispatch：**含有异步操作，数据提交至`actions`，可用于向后台提交数据

  ```js
  /*写法示例：*/ this.$store.dispatch('isLogin', true);
  ```

- **commit：**同步操作，数据提交至`mutation`，可用于登录成功后读取用户信息写到缓存里

  ```js
  /*写法示例：*/ this.$store.commit('loginStatus', 1);
  ```

两者都可以以载荷形式或者对象风格的方式进行提交

------

## Element UI

### el-date-picker

当日期选择器为日期区间时（值为数组），如果想要修改它的值，需要整个数组一起修改，不能只修改其中一个，否则视图不会更新。

### el-image

图片容器，在保留原生img的特性下，支持懒加载，自定义占位、加载失败等。

**属性**

| 参数             | 说明                                                         | 类型                 | 可选值                                     | 默认值                                         |
| :--------------- | :----------------------------------------------------------- | :------------------- | :----------------------------------------- | :--------------------------------------------- |
| src              | 图片源，同原生                                               | string               | —                                          | -                                              |
| fit              | 确定图片如何适应容器框，同原生 [object-fit](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit) | string               | fill / contain / cover / none / scale-down | -                                              |
| alt              | 原生 alt                                                     | string               | -                                          | -                                              |
| referrer-policy  | 原生 referrerPolicy                                          | string               | -                                          | -                                              |
| lazy             | 是否开启懒加载                                               | boolean              | —                                          | false                                          |
| scroll-container | 开启懒加载后，监听 scroll 事件的容器                         | string / HTMLElement | —                                          | 最近一个 overflow 值为 auto 或 scroll 的父元素 |
| preview-src-list | 开启图片预览功能                                             | Array                | —                                          | -                                              |
| z-index          | 设置图片预览的 z-index                                       | Number               | —                                          | 2000                                           |

**属性说明**

- `src`：图片源

- `fit`：

  | 值         | 描述                                                         |
  | ---------- | ------------------------------------------------------------ |
  | fill       | 默认，不保证保持原有的比例，内容拉伸填充整个内容容器。       |
  | contain    | 保持原有尺寸比例。内容被缩放。                               |
  | cover      | 保持原有尺寸比例。但部分内容可能被剪切。                     |
  | none       | 保留原有元素内容的长度和宽度，也就是说内容不会被重置。       |
  | scale-down | 保持原有尺寸比例。内容的尺寸与 none 或 contain 中的一个相同，取决于它们两个之间谁得到的对象尺寸会更小一些。 |

- `alt`：规定图像的替代文本。

- `lazy`：是否开启懒加载。

- `scroll-container`：开启懒加载后，监听`scroll`事件的容器。若没指定，默认为最近一个 overflow 值为 auto 或 scroll 的父元素。

- `preview-src-list`：开启图片预览功能，类型为`Array`。

- `z-index`：设置图片预览的 `z-index`。

### el-row

Element UI中的layout布局。

https://element.eleme.cn/#/zh-CN/component/layout#row-attributes

- `gutter`栅格间隔，表示每个块之间的距离。
- `type`布局模式，可选`flex`。
- `justify`：`flex`布局下的水平排列方式。可选值：`start`/`end`/`center`/`space-around`/`space-between`默认`start`
- `align`：`flex`布局下的垂直排列方式。可选值：`top`/`middle`/`bottom`默认`top`
- `tag`自定义元素标签。可选值`*`默认`div`



### el-col

Element UI中的layout布局。将页面横向分割成24等份，当`span`值为24时该部分的宽充满整个页面。

https://element.eleme.cn/#/zh-CN/component/layout#row-attributes

- `span`栅格占据的列数
- `offset`栅格左侧的间隔格数
- `push`栅格向右移动格数
- `pull`栅格向左移动格数
- `xs`：`<768px` 响应式栅格数或者栅格属性对象
- `sm`：`≥768px` 响应式栅格数或者栅格属性对象
- `md`：`≥992px` 响应式栅格数或者栅格属性对象
- `lg`：`≥1200px` 响应式栅格数或者栅格属性对象
- `xl`：`≥1920px` 响应式栅格数或者栅格属性对象
- `tag`自定义元素标签。可选值`*`默认`div`

其中，`xs`,`sm`,`md`,`lg`,`xl`分别表示超小、小、中、大、超大的显示屏幕，具体宽度见上表。

例如`lg="4"`，表示在宽度为1200px以上，1920px以下的显示屏中，可以显示24/4个el-col元素，换句话说一个el-col元素占屏幕的六分之一大小。

```vue
<el-row :gutter="10">
	<el-col :span="5"><div id="a1"></div></el-col>
	<el-col :span="5"><div id="a2"></div></el-col>
	<el-col :span="14"><div id="a3"></div></el-col>
</el-row>
```

其中，`:gutter="10"`是指每个`el-col`相隔10px；`：span="5"`、`：span="5"`、`：span="14"`指每个`el-col`占`el-row`的**比例**。所有的`span`值**相加等于24**。如上`span="5"`，即表示该`el-col`占整个`el-row`长度的5/24。

### el-pagination

当数据量过多时，使用分页功能分解数据。

https://element.eleme.cn/#/zh-CN/component/pagination#attributes

- `background`是否为分页按钮添加背景色。默认`false`
- `total`总条目数
- `page-count`总页数，`total` 和 `page-count` 设置任意一个就可以达到显示页码的功能；如果要支持 `page-sizes` 的更改，则需要使用 `total` 属性
- `pager-count`页码按钮的数量，当总页数超过该值时会折叠，需要为大于等于 5 且小于等于 21 的奇数。默认7
- `current-page`当前页数，支持 `.sync` 修饰符。默认1
- `page-size`每页显示条目个数，支持`.sync`修饰符。默认10
- `page-sizes`每页显示个数选择器的选项设置。默认[10, 20, 30, 40, 50, 100]
- `layout`组件布局，子组件名用逗号分隔。可选`sizes`, `prev`, `pager`, `next`, `jumper`, `->`, `total`, `slot`。默认`prev`, `pager`, `next`, `jumper`, `->`, `total`

### el-dialog

在保留当前页面状态的情况下，告知用户并承载相关操作。分为两部分，主题body和框脚footer。

dialog可以嵌套表格、表单甚至另一个dialog。

https://element.eleme.cn/#/zh-CN/component/dialog#attributes

- `：visiable.sync`为`true`时显示对话框。
- `footer`需要具名为`footer`的`slot`，例如：
  `<span slot="footer" class="dialog-footer">`
  `</span>`
- `：before-close`定义关闭对话框之前执行的方法或语句。例如：
  `:before-close="handleClose"`
- `center`使dialog的标题和底部居中显示，内容是默认不居中的，若要是内容居中，则需另外添加css。

### el-form

element UI中的表格组件。

https://element.eleme.cn/#/zh-CN/component/form

在<el-form></el-form>中，表单个体被<el-form-item>组件标签扩入。

- `：inline`用于让表格以单行呈现，默认值为`false`，启用则改为`true`。
- `：model`用于绑定数据。
- `@submit.native.prevent`用于取消搜索框中按回车键提交请求的操作，可以避免部分功能的误触发。

**表单验证：**

`trigger`类型

```js
//第一种
{
	required: true,
	message: '请输入字典项',
	trigger: 'blur'
},
//第二种
{
	required: true,
	message: '请输入字典项',
	trigger: 'change'
},
//第三种

{
	pattern: /^[A-Za-z0-9_]+$/,
	message: '字典项只能由 大小写字母、数字、下划线组成',
	trigger: ['blur', 'change']
}

// 
enName: [
  {
    required: true,
    message: '组件英文名称',
    trigger: 'blur'
  },
  { 
    pattern: /^[A-Za-z0-9_]+$/,
    message: '组件英文名称只能由 大小写字母、数字、下划线组成', 
    trigger: 'blur' 
  }
]
```

**bug记录：**

需求描述：某个需求中，表单有上下ab两项，均有表单校验，ab项是联动校验。

bug描述：某个对b项的操作触发了b的校验，之后，对a项进行修改，使得a、b满足了联动校验的条件，但**b的校验并没有消失**。

原因：不详。

无效解决方式：在a项的校验规则中调用b项校验方法，该方式即使成功触发了b项校验的`callback()`，b项的校验也不会消失。

正确解决方式：对a项进行修改时，在a项的`change`监听函数中添加手动触发b项表单验证的方法即可。

代码：

```js
// html
<el-form ref="myForm">

a: [
    {
        validator: (rule, value, callback) => {
            ...
        }
    }
],
b: [
    {
        validator: (rule, value, callback) => {
            ...
        }
    }
]

// method
changeA(val) {
    ...
    this.$refs.myForm.validateField('a') // 手动触发a项校验
}
```

### el-input

输入框。

https://element.eleme.cn/#/zh-CN/component/input

- `v-model`用于绑定输入框中的数据。本质上是一个语法糖，例如：
  <input v-model="test">
  本质上是
  `<input :value="test" @input="test=$event.target.value">`，其中`@input`是对<input>输入事件的一个监听,`:value="test"`是将监听事件中的数据放入到<input>。
- `：placeholder`用于显示输入框中的提示内容。
- `1wclearable`用于在输入字符时在输入框右端显示一个删除图标，即允许一键删除。
- `@keyup.enter.native="getList()"`回车键提交请求。

### el-button

Element UI中的按钮组件。

https://element.eleme.cn/#/zh-CN/component/button

- `type`用于选择使用的按钮的样式。
- `icon`用于按钮中的图标。

### el-table

Element UI中的表格组件。

https://element.eleme.cn/#/zh-CN/component/table

当`el-table`元素中注入`data`对象数组后，在`el-table-column`中用`prop`属性来对应对象中的键名即可填入数据，用`label`属性来定义表格的列名。可以使用`width`属性来定义列宽。

- `border`用于给表格赋予边框。

## Echarts

### 一个图表中多个y轴

循环创建多个y轴时，在`series`中配置：

```js
yAxisIndex: i
```

即将每个y轴设置为独立，即可单独对每一条线作不同的数据单位处理。

### 点击事件重复触发两次问题

在点击事件上方添加事件取消即可

```js
// 关掉事件
this.chart.off('click')
// 点击事件
this.chart.on('click', (params) => {
  this.$emit('checkDayAlarm', params.name)
})
```

**使用Echarts画任何图时，最外面一定要有一个固定高度的容器。**

### 饼图的标签居中问题

饼图标签不居中是因为没有使用富文本功能。

原代码：

```js
label: {
	show: true,
	formatter: '{b}\n{c}\n({d}%)',
	align: 'center'              
}
```

使用富文本后：

```js
label: {
	show: true,
	formatter: [
		'{dvName|{b}}',
		// '{bg|}',
		'{counts|{d}%}  ' + ' {percent|({c})}'
		].join('\n'),
	rich: {
		dvName: {
			// color: '#747474',
			align: 'center',
			lineHeight: 18,
			position: 'relative'
			},
		bg: {
			borderColor: '#dadada',
			width: '100%',
			borderWidth: 0.5,
			height: 0
		},
		percent: {
			color: '#333333',
			lineHeight: 15,
			align: 'center'
		},
		counts: {
			color: '#333333',
			position: 'inside',
			align: 'center'
		}
}
```

其中，`formatter`中用字符串数组后接`.join('\n')`来代替原代码中的一整串字符串中的`\n`。`{title|{b}}`中的`title`是自定义的文本块名称，`|`后面是具体的值，在`rich`中设置对应文本块的具体样式。

### 渐变

echarts内置的渐变色生成器

**echarts.graphic.LinearGradient**

```js
itemStyle: {
            normal: {
              barBorderRadius: 10,
              color: new echarts.graphic.LinearGradient( // 四个参数代表渐变的起始位置，分别是右下左上
                0, 1, 0, 0, // 渐变由下往上
                [
                  { offset: 0, color: '#06B5D7' }, // offset设置该颜色在柱上的位置，0代表起始位置
                  { offset: 0.5, color: '#44C0C1' }, // 柱图渐变色
                  { offset: 1, color: '#ffff00' } // 柱图渐变色
                ]
              )
            }
          },
          animationDuration
        },
```

**多种颜色渐变：**

```js
series: {
          name: '舆论',
          type: 'bar',
          smooth: true,
          barWidth: 10,
          data: data, 
          itemStyle: {
            normal: {
              color: function(params) {
                var colorList = [
                  ['#FFBC1B', '#FF6804'],
                  ['#67FDC6', '#00F5F5'],
                  ['#52F890', '#26A864'],
                  ['#5DA2FF', '#004CC9'],
                  ['#9882F9', '#5533E9']
                ];

                var index = params.dataIndex % colorList.length;
                // 如果是纵向的图标，则改为0, 0 , 0, 1
                return new that.$echarts.graphic.LinearGradient(1, 0, 0, 0, [
                  { offset: 0, color: colorList[index][0] },
                  { offset: 1, color: colorList[index][1] }
                ]);
              },
              barBorderRadius: 5 //柱状角成椭圆形
            }
          }
        },
```



### 样式设置

格式：
`series: [{name,type,radius,emphasis: {},data: []}]`

### legend

#### selected

图例选中状态表。示例：

```javascript
selected: {
    // 选中'系列1'
    '系列1': true,
    // 不选中'系列2'
    '系列2': false
}
```

**注意！**这里的括号是**大括号{ }**，而不是中括号[ ]。

------

## Github

### 使用Github管理本地项目

**目的：**`Github`是分布式管理仓库，不同于`SVN`，我们可以在办公室将写好的代码上传到`git`，然后在家里把代码`pull`下来，实现异地同步，这在`SVN`中是无法实现的。

**步骤：**

**下载git**

从[git下载官网](https://git-scm.com/downloads)下载git并安装，在任意文件夹中右键，可以看到`Git GUI Here`和`Git Bash Here`即安装成功

**建立本地git仓库**

选择一个文件夹，在里面存放要上传的文件，右键空白处，点击`Git Bash Here`呼出`git`控制台

1. 将该文件夹作为git目录，并查看文件状态

   ```
   git init
   git status
   ```

2. 此时文件夹成为工作区，将文件夹中所有文件添加到暂存区

   ```
   git add .
   ```

3. 提交在暂存区中的文件到本地仓库，设置该次提交的信息

   ```
   git commit -m '第一次提交测试'
   ```

4. 推送到远程仓库

   ```
   git push
   ```

**注册Github**

登录[Github官网](https://github.com/)注册账号（可能要翻墙，可下载佛跳墙）

**在Github中新建远程仓库**

`new`一个新仓库

![image-20210604153118997](C:\Users\82317\AppData\Roaming\Typora\typora-user-images\image-20210604153118997.png)

设置仓库名称、描述和访问权限

![image-20210604153855832](C:\Users\82317\AppData\Roaming\Typora\typora-user-images\image-20210604153855832.png)

**新建后，本地仓库关联远程仓库**

复制命令行`git remote add origin https://github.com/Zzh-98131/A-Test-Repository.git`并执行

还要注意切换分支，如果还不行，尝试

```
 git push --set-upstream origin master
```

![image-20210604154715896](C:\Users\82317\AppData\Roaming\Typora\typora-user-images\image-20210604154715896.png)

成功！可在网站上自行切换分支或删除仓库等

![image-20210604160245212](C:\Users\82317\AppData\Roaming\Typora\typora-user-images\image-20210604160245212.png)

**更新项目**

文件夹空白处右键呼出`git`命令行，依次输入

```
git add .
git commit -m 'Message of this time.'
git push
```

------

## 草稿

1. 修改了设备列表页的搜索和按钮点击逻辑
2. 导航侧栏恢复伸缩功能，收缩时鼠标悬浮显示二级菜单
3. 调整了面包屑的展示模式
4. 设备详细页无流程图时根据两种尺寸的屏幕采用两种布局
5. 公共表格组件优化
6. 提取公共展示组件



综合管理系统的功能模块主要是监控和运维。

监控是对站点和设备等的状态的监控，比较“宏观”，包括数据的采集（状态、数量、告警）、数据可视化（数据表格、图表）和数据分析（数据统计报表）。

运维是对产品的一个跟踪维护，是“具体”的，对具体的站点、具体设备、具体用户和告警的操作。

最后的系统管理，则是对运维系统本身信息和操作的一些记录。

